<!--
***********************************************************************************************
Xamarin.Shared.targets

WARNING:  DO NOT MODIFY this file unless you are knowledgeable about MSBuild and have
  created a backup copy.  Incorrect changes to this file will make it
  impossible to load or build your projects from the command-line or the IDE.

This file imports the version- and platform-specific targets for the project importing
this file. This file also defines targets to produce an error if the specified targets
file does not exist, but the project is built anyway (command-line or IDE build).

Copyright (C) 2018 Microsoft. All rights reserved.
***********************************************************************************************
-->

<!-- This is shared between Xamarin.iOS and Xamarin.Mac -->

<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">

	<PropertyGroup Condition="'$(_TaskAssemblyName)' == ''">
		<_TaskAssemblyName Condition="'$(_PlatformName)' == 'iOS' Or '$(_PlatformName)' == 'tvOS' Or '$(_PlatformName)' == 'watchOS' Or '$(_PlatformName)' == 'MacCatalyst'">$(MSBuildThisFileDirectory)..\iOS\Xamarin.iOS.Tasks.dll</_TaskAssemblyName>
		<_TaskAssemblyName Condition="'$(_PlatformName)' == 'macOS'">$(MSBuildThisFileDirectory)Xamarin.Mac.Tasks.dll</_TaskAssemblyName>
	</PropertyGroup>

	<!-- Tasks that override built-in tasks to support remoting from VS/Windows -->
	<UsingTask TaskName="Microsoft.Build.Tasks.Copy" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Delete" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Exec" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Microsoft.Build.Tasks.MakeDir" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Move" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Microsoft.Build.Tasks.RemoveDir" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Microsoft.Build.Tasks.Touch" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Microsoft.Build.Tasks.WriteLinesToFile" AssemblyFile="$(_TaskAssemblyName)" />

	<!-- Xamarin.iOS-specific tasks. Some of these are duplicated with the Xamarin.Mac ones below, and should eventually be re-namespaced to be in Xamarin.MacDev -->
	<UsingTask Condition="'$(_PlatformName)' != 'macOS'" TaskName="Xamarin.iOS.Tasks.CollectAssetPacks" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask Condition="'$(_PlatformName)' != 'macOS'" TaskName="Xamarin.iOS.Tasks.CollectITunesArtwork" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask Condition="'$(_PlatformName)' != 'macOS'" TaskName="Xamarin.iOS.Tasks.CollectITunesSourceFiles" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask Condition="'$(_PlatformName)' != 'macOS'" TaskName="Xamarin.iOS.Tasks.CompileAppManifest" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask Condition="'$(_PlatformName)' != 'macOS'" TaskName="Xamarin.iOS.Tasks.CompileITunesMetadata" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask Condition="'$(_PlatformName)' != 'macOS'" TaskName="Xamarin.iOS.Tasks.CompileSceneKitAssets" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask Condition="'$(_PlatformName)' != 'macOS'" TaskName="Xamarin.iOS.Tasks.CreateAssetPack" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask Condition="'$(_PlatformName)' != 'macOS'" TaskName="Xamarin.iOS.Tasks.CreateEmbeddedResources" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask Condition="'$(_PlatformName)' != 'macOS'" TaskName="Xamarin.iOS.Tasks.DetectSdkLocations" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask Condition="'$(_PlatformName)' != 'macOS'" TaskName="Xamarin.iOS.Tasks.DetectSigningIdentity" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask Condition="'$(_PlatformName)' != 'macOS'" TaskName="Xamarin.iOS.Tasks.FindWatchOS2AppBundle" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask Condition="'$(_PlatformName)' != 'macOS'" TaskName="Xamarin.iOS.Tasks.GetMlaunchArguments" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask Condition="'$(_PlatformName)' != 'macOS'" TaskName="Xamarin.iOS.Tasks.MTouch" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask Condition="'$(_PlatformName)' != 'macOS'" TaskName="Xamarin.iOS.Tasks.ParseDeviceSpecificBuildInformation" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask Condition="'$(_PlatformName)' != 'macOS'" TaskName="Xamarin.iOS.Tasks.PrepareNativeReferences" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask Condition="'$(_PlatformName)' != 'macOS'" TaskName="Xamarin.iOS.Tasks.ResolveNativeWatchApp" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask Condition="'$(_PlatformName)' != 'macOS'" TaskName="Xamarin.iOS.Tasks.ResolveUniversalTypeIdentifiers" AssemblyFile="Xamarin.iOS.Tasks.dll" />
	<UsingTask Condition="'$(_PlatformName)' != 'macOS'" TaskName="Xamarin.iOS.Tasks.ValidateAppBundleTask" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask Condition="'$(_PlatformName)' != 'macOS'" TaskName="Xamarin.iOS.Tasks.VerifyXcodeVersion" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask Condition="'$(_PlatformName)' != 'macOS'" TaskName="Xamarin.iOS.Tasks.WriteAssetPackManifest" AssemblyFile="$(_TaskAssemblyName)" />

	<!-- Xamarin.Mac-specific tasks. Some of these are duplicated with the Xamarin.iOS ones above, and should eventually be re-namespaced to be in Xamarin.MacDev -->
	<UsingTask Condition="'$(_PlatformName)' == 'macOS'" TaskName="Xamarin.Mac.Tasks.CompileAppManifest" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask Condition="'$(_PlatformName)' == 'macOS'" TaskName="Xamarin.Mac.Tasks.CompileSceneKitAssets" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask Condition="'$(_PlatformName)' == 'macOS'" TaskName="Xamarin.Mac.Tasks.CreateEmbeddedResources" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask Condition="'$(_PlatformName)' == 'macOS'" TaskName="Xamarin.Mac.Tasks.DetectSdkLocations" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask Condition="'$(_PlatformName)' == 'macOS'" TaskName="Xamarin.Mac.Tasks.DetectSigningIdentity" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask Condition="'$(_PlatformName)' == 'macOS'" TaskName="Xamarin.Mac.Tasks.Mmp" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask Condition="'$(_PlatformName)' == 'macOS'" TaskName="Xamarin.Mac.Tasks.PrepareNativeReferences" AssemblyFile="$(_TaskAssemblyName)" />

	<!-- Tasks shared between Xamarin.iOS and Xamarin.Mac -->
	<UsingTask TaskName="Xamarin.MacDev.Tasks.ACTool" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.ALToolUpload" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.ALToolValidate" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.Archive" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.ArTool" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.AOTCompile" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.BTouch" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.Codesign" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.CodesignVerify" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.CollectBundleResources" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.CollectFrameworks" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.CompileEntitlements" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.ComputeBundleLocation" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.ComputeBundleResourceOutputPaths" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.CoreMLCompiler" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.CreateAssetPackManifest" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.CreateBindingResourcePackage" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.CreateDebugConfiguration" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.CreateDebugSettings" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.CreateInstallerPackage" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.CreatePkgInfo" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.CompileProductDefinition" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.DetectDebugNetworkConfiguration" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.Ditto" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.DSymUtil" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.EmbedProvisionProfile" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.FindCscCompiler" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.FindItemWithLogicalName" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.GenerateBundleName" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.GetDirectories" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.GetFiles" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.GetFileSystemEntries" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.GetFullPath" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.GetPropertyListValue" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.IBTool" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.Metal" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.MetalLib" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.OptimizeImage" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.OptimizePropertyList" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.PackLibraryResources" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.ParseBundlerArguments" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.PrepareResourceRules" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.PropertyListEditor" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.ReadAppManifest" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.ReadItemsFromFile" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.ResolveNativeReferences" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.ScnTool" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.SmartCopy" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.SpotlightIndexer" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.SymbolStrip" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.TextureAtlas" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.UnpackLibraryResources" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.WriteAppManifest" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.WriteItemsToFile" AssemblyFile="$(_TaskAssemblyName)" />
	<UsingTask TaskName="Xamarin.MacDev.Tasks.Zip" AssemblyFile="$(_TaskAssemblyName)" />

	<Import Project="$(MSBuildThisFileDirectory)$(MSBuildThisFileName).Before.targets"
			Condition="Exists('$(MSBuildThisFileDirectory)$(MSBuildThisFileName).Before.targets')"/>

	<ItemDefinitionGroup>
		<_BundleResourceWithLogicalName>
			<Optimize />
		</_BundleResourceWithLogicalName>
	</ItemDefinitionGroup>

	<!--
		@(NativeReference) are not safe to use as an Input to a task, as frameworks are a directory and will appears unbuilt every time.
		So we split it into two camps as a prebuild step
	-->
	<Target Name="_ExpandNativeReferences" Condition="'$(DesignTimeBuild)' != 'true'" DependsOnTargets="_DetectSdkLocations;_ComputeTargetArchitectures">
		<ItemGroup>
			<_XCFrameworkNativeReference Include="@(NativeReference -> '%(Identity)/.')" Condition="'%(Extension)' == '.xcframework'" />
			<_FrameworkNativeReference Include="@(NativeReference -> '%(Identity)/%(Filename)')" Condition="'%(Extension)' == '.framework'" />
			<_FileNativeReference Include="@(NativeReference)" Condition="'%(Extension)' != '.framework' And '%(Extension)' != '.xcframework'" />
		</ItemGroup>
		<ResolveNativeReferences
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '$(IsBindingProject)' != 'true'"
			Architectures="$(TargetArchitectures)"
			IntermediateOutputPath="$(DeviceSpecificIntermediateOutputPath)"
			NativeReferences="@(_XCFrameworkNativeReference);@(_FrameworkNativeReference)"
			References="@(ReferencePath)"
			SdkIsSimulator="$(_SdkIsSimulator)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
			>
			<Output TaskParameter="NativeFrameworks" ItemName="_ResolvedNativeReference" />
		</ResolveNativeReferences>

		<ItemGroup>
			<_FrameworkNativeReference Include="@(_ResolvedNativeReference)" Condition="'%(Kind)' == 'Framework'" />
			<_FileNativeReference Include="@(_ResolvedNativeReference)" Condition="'%(Kind)' == 'Static' Or '%(Kind)' == 'Dynamic'" />
		</ItemGroup>
	</Target>
	
	<PropertyGroup>
		<BindingResourcePath>$(OutputPath)$(AssemblyName).resources</BindingResourcePath>
	</PropertyGroup>

	<Target Name="_CreateBindingResourcePackage"
		Condition="'$(DesignTimeBuild)' != 'true' And '$(NoBindingEmbedding)' == 'true'"
		DependsOnTargets="_ExpandNativeReferences"
		Inputs="$(MSBuildAllProjects);$(MSBuildProjectFullPath);@(ObjcBindingApiDefinition);@(ObjcBindingCoreSource);@(ReferencePath);@(ObjcBindingNativeLibrary);@(_FrameworkNativeReference);@(_FileNativeReference)"
		Outputs="$(BindingResourcePath).stamp">

		<!-- CompressBindingResourcePackage specifies whether the package should be compressed (zipped) or not
			true: compressed (we produce an Assembly.resources directory)
			false: not compressed (we produce an Assembly.resources.zip file)
			auto: compressed if there are any symlinks
			The default is 'false' for legacy Xamarin projects (for compatibility) and 'auto' for .NET projects (NuGet doesn't handle symlinks properly, so this way it's not necessary to set this property to create NuGets that work)
		-->
		<PropertyGroup Condition="'$(CompressBindingResourcePackage)' == ''">
			<CompressBindingResourcePackage Condition="'$(UsingAppleNETSdk)' == 'true'">auto</CompressBindingResourcePackage>
			<CompressBindingResourcePackage Condition="'$(UsingAppleNETSdk)' != 'true'">false</CompressBindingResourcePackage>
		</PropertyGroup>

		<CreateBindingResourcePackage Condition="'$(IsMacEnabled)' == 'true'"
			SessionId="$(BuildSessionId)"
			NativeReferences="@(NativeReference)"
			BindingResourcePath="$(BindingResourcePath)"
			Compress="$(CompressBindingResourcePackage)"
			IntermediateOutputPath="$(DeviceSpecificIntermediateOutputPath)"
			>
		</CreateBindingResourcePackage>

		<MakeDir
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			Directories="$([System.IO.Path]::GetDirectoryName($(BindingResourcePath)))"
		/>

		<Touch
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			AlwaysCreate="true"
			Files="$(BindingResourcePath).stamp"
			>
			<Output TaskParameter="TouchedFiles" ItemName="FileWrites" />
		</Touch>
	</Target>

	<!--
		Binding projects may include NativeReference items, which makes the 'pack' target want to include a Native.$(AssemblyName).manifest into the NuGet,
		which obviously fails because we don't create such a file. So let's remove that file.

		Ref: https://github.com/dotnet/msbuild/blob/3a1e456fe227f3e2b190b434578844c31e8bcb4a/src/Tasks/Microsoft.Common.CurrentVersion.targets#L6111-L6118
		Ref: https://github.com/dotnet/msbuild/issues/4584
	-->
	<PropertyGroup>
		<GenerateNuspecDependsOn>
			$(GenerateNuspecDependsOn);
			_RemoveNativeManifestFromPack;
		</GenerateNuspecDependsOn>
	</PropertyGroup>
	<Target Name="_RemoveNativeManifestFromPack">
		<ItemGroup>
			<_BuildOutputInPackage Remove="@(_BuildOutputInPackage)" Condition="'%(Filename)%(Extension)' == '$(_DeploymentTargetApplicationManifestFileName)'" />
		</ItemGroup>
	</Target>

	<!--
		Add any binding resource packages to the nupkg

		Ref: https://github.com/dotnet/sdk/issues/14042#issuecomment-716868311
		Ref: https://github.com/NuGet/Home/issues/10063#issuecomment-713083004
		Ref: https://github.com/xamarin/xamarin-android/blob/681887ebdbd192ce7ce1cd02221d4939599ba762/src/Xamarin.Android.Build.Tasks/Microsoft.Android.Sdk/targets/Microsoft.Android.Sdk.AndroidLibraries.targets#L86-L99
	-->
	<PropertyGroup>
		<TargetsForTfmSpecificContentInPackage>$(TargetsForTfmSpecificContentInPackage);_IncludeBindingResourcesInNuGetPackage</TargetsForTfmSpecificContentInPackage>
	</PropertyGroup>
	<Target Name="_IncludeBindingResourcesInNuGetPackage"
		Condition="'$(IsMacEnabled)' == 'true' And '$(IncludeBuildOutput)' != 'false'"
	>
		<PropertyGroup>
			<_HasOldStyleBindingItems Condition="@(ObjcBindingNativeLibrary->Count()) > 0">true</_HasOldStyleBindingItems>
		</PropertyGroup>
		<Error Condition="'$(_HasOldStyleBindingItems)' == 'true'" Text="Creating a NuGet package is not supported for projects that have ObjcBindingNativeLibrary items. Migrate to use NativeReference items instead." />

		<!-- The 'GetNuGetShortFolderName' task only exists for .NET, so hardcode values for _NuGetShortFolderName for legacy builds -->
		<PropertyGroup Condition="'$(UsingAppleNETSdk)' != 'true'">
			<_NuGetShortFolderName Condition="'$(TargetFrameworkIdentifier)' == 'Xamarin.iOS'">xamarinios10</_NuGetShortFolderName>
			<_NuGetShortFolderName Condition="'$(TargetFrameworkIdentifier)' == 'Xamarin.TVOS'">xamarintvos10</_NuGetShortFolderName>
			<_NuGetShortFolderName Condition="'$(TargetFrameworkIdentifier)' == 'Xamarin.WatchOS'">xamarinwatch10</_NuGetShortFolderName>
			<_NuGetShortFolderName Condition="'$(TargetFrameworkIdentifier)' == 'Xamarin.Mac'">xamarinmac10</_NuGetShortFolderName>
		</PropertyGroup>

		<!-- Figure out where to place the binding resources (see references above for more info) -->
		<GetNuGetShortFolderName
			TargetFrameworkMoniker="$(TargetFrameworkMoniker)"
			TargetPlatformMoniker="$(TargetPlatformMoniker)"
			Condition="'$(_NuGetShortFolderName)' == ''"
			>
			<Output TaskParameter="NuGetShortFolderName" PropertyName="_NuGetShortFolderName" />
		</GetNuGetShortFolderName>

		<!-- The binding project may either produce a 'MyBindingProject.resources' directory, or a compressed 'MyBindingProject.resources.zip' version -->
		<PropertyGroup>
			<_AppleBindingResourceBasePath>$(TargetDir)$(TargetName).resources</_AppleBindingResourceBasePath>
		</PropertyGroup>

		<ItemGroup>
			<!-- Add all the files that might exist in any binding resource packages -->
			<_AppleBindingResource Include="$(_AppleBindingResourceBasePath)\**\*" PackagePath="lib\$(_NuGetShortFolderName)\$(TargetName).resources" />
			<!-- Add any compressed files that might exist as well -->
			<_AppleBindingResource Include="$(_AppleBindingResourceBasePath).zip" PackagePath="lib\$(_NuGetShortFolderName)" Condition="Exists('$(_AppleBindingResourceBasePath).zip')" />
		</ItemGroup>

		<!-- Add what we found to the NuGet -->
		<ItemGroup>
			<TfmSpecificPackageFile Include="@(_AppleBindingResource)" />
		</ItemGroup>
	</Target>

	<!-- Cleaning via FileWrites leaves empty framework directories on disk, so nuke via RemoveDir -->
	<PropertyGroup>
		<CleanDependsOn>
			$(CleanDependsOn);
			_CleanAppBundle;
			_CleanBindingResourcePackage;
			_CleanDebugSymbols;
			_CleanDeviceSpecificOutput;
			_CleanIntermediateToolOutput;
			_CleanITunesArtwork;
		</CleanDependsOn>
	</PropertyGroup>

	<Target Name="_CleanAppBundle" Condition="'$(_CanOutputAppBundle)' == 'true'" DependsOnTargets="_GenerateBundleName">
		<RemoveDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Directories="$(_AppBundlePath)" />
		<Delete SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Files="$(DeviceSpecificOutputPath)bundler.stamp" />
	</Target>

	<Target Name="_CleanAppBundleRootDirectory" Condition="'$(_PlatformName)' == 'MacCatalyst' Or '$(_PlatformName)' == 'macOS'">
		<!-- There shouldn't be any files in the root directory of the app bundle for macOS or Mac Catalyst (signing will fail) -->

		<!-- Delete any crash dumps in the app bundle that might exist. Ref: https://github.com/xamarin/xamarin-macios/issues/12320 -->
		<!-- Use a task to collect the files, so that we get the correct behavior on Windows -->
		<GetFileSystemEntries
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And ('$(_PlatformName)' == 'MacCatalyst' Or '$(_PlatformName)' == 'macOS')"
			DirectoryPath="$(AppBundleDir)"
			Pattern="mono_crash.*"
			Recursive="false"
			IncludeDirectories="false"
			>
			<Output TaskParameter="Entries" ItemName="_MonoCrashDumpsInAppBundle" />
		</GetFileSystemEntries>
		<Delete
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And ('$(_PlatformName)' == 'MacCatalyst' Or '$(_PlatformName)' == 'macOS')"
			Files="@(_MonoCrashDumpsInAppBundle)"
		/>

		<!-- Warn about any files that are left -->
		<GetFileSystemEntries
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And ('$(_PlatformName)' == 'MacCatalyst' Or '$(_PlatformName)' == 'macOS')"
			DirectoryPath="$(AppBundleDir)"
			Pattern="*"
			Recursive="false"
			IncludeDirectories="false"
			>
			<Output TaskParameter="Entries" ItemName="_FilesInAppBundleRootDirectory" />
		</GetFileSystemEntries>
		<Warning Text="Found files in the root directory of the app bundle. This will likely cause codesign to fail. Files:%0a@(_FilesInAppBundleRootDirectory, '%0a')" Condition="@(_FilesInAppBundleRootDirectory->Count()) &gt; 0"/>
	</Target>

	<Target Name="_CleanBindingResourcePackage">
		<RemoveDir Directories="$(BindingResourcePath);" />  
	</Target>

	<Target Name="_CleanDebugSymbols" Condition="'$(_CanOutputAppBundle)' == 'true'" DependsOnTargets="_GenerateBundleName">
		<GetDirectories SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Path="$(DeviceSpecificOutputPath)" Pattern="*.dSYM">
			<Output TaskParameter="Directories" ItemName="_DebugSymbolDir" />
		</GetDirectories>

		<RemoveDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Directories="$(AppBundleDir).mSYM;@(_DebugSymbolDir)" />
		<Delete SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true' And '$(IsAppExtension)' == 'false'" Files="$(DeviceSpecificOutputPath)*.bcsymbolmap" />
		<Delete SessionId="$(BuildSessionId)" Condition="(('$(IsMacEnabled)' == 'true' And '$(IsAppExtension)' == 'true') Or '$(_PlatformName)' == 'macOS')" Files="$(DeviceSpecificOutputPath)dsym.items" />
	</Target>

	<Target Name="_CleanITunesArtwork" Condition="'$(_CanArchive)' == 'true'" DependsOnTargets="_ComputeTargetArchitectures">
		<Delete SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Files="$(DeviceSpecificOutputPath)iTunesMetadata.plist;$(DeviceSpecificOutputPath)iTunesArtwork@2x;$(DeviceSpecificOutputPath)iTunesArtwork" />
	</Target>

	<Target Name="_CleanDeviceSpecificOutput" Condition="'$(_CanOutputAppBundle)' == 'true'">
		<RemoveDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Directories="$(IntermediateOutputPath)device-builds;$(OutputPath)device-builds" />
	</Target>

	<Target Name="_CleanIntermediateToolOutput" DependsOnTargets="_ComputeTargetArchitectures">
		<RemoveDir SessionId="$(BuildSessionId)" 
			Condition="'$(IsMacEnabled)' == 'true'" 
			Directories="$(DeviceSpecificIntermediateOutputPath)actool;
					$(DeviceSpecificIntermediateOutputPath)assetpacks;
					$(DeviceSpecificIntermediateOutputPath)codesign;
					$(DeviceSpecificIntermediateOutputPath)coremlc;
					$(DeviceSpecificIntermediateOutputPath)ibtool;
					$(DeviceSpecificIntermediateOutputPath)ibtool-link;
					$(DeviceSpecificIntermediateOutputPath)ibtool-manifests;
					$(DeviceSpecificIntermediateOutputPath)ipa;
					$(DeviceSpecificIntermediateOutputPath)metal;
					$(DeviceSpecificIntermediateOutputPath)optimized;
					$(DeviceSpecificIntermediateOutputPath)scntool;
					$(DeviceSpecificIntermediateOutputPath)TextureAtlas;
					$(DeviceSpecificIntermediateOutputPath)mtouch-cache;
					$(DeviceSpecificIntermediateOutputPath)" />

		<ItemGroup>
			<_IpaPackageFile Include="$(DeviceSpecificOutputPath)*.ipa" />
		</ItemGroup>

		<Delete SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true' And '$(IsAppExtension)' == 'true'" Files="$(DeviceSpecificOutputPath)codesign.items" />
		<Delete SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Files="@(_IpaPackageFile)" />
	</Target>

	<Target Name="_AddExtraReferences" BeforeTargets="ResolveAssemblyReferences" Condition="'$(DisableExtraReferences)' != 'true' And '$(UsingAppleNETSdk)' != 'true'">
		<ItemGroup>
			<!-- https://github.com/mono/mono/issues/13483 -->
			<Reference Include="System.Drawing.Common.dll" />
		</ItemGroup>
	</Target>

	<PropertyGroup>
		<_CollectBundleResourcesDependsOn>
			$(_CollectBundleResourcesDependsOn);
			_ComputeTargetArchitectures;
			_ComputeTargetFrameworkMoniker;
		</_CollectBundleResourcesDependsOn>
		<_CollectBundleResourcesDependsOn Condition="'$(IsBindingProject)' != 'true'">
			$(_CollectBundleResourcesDependsOn);
			_CompileImageAssets;
			_CompileInterfaceDefinitions;
			_CompileSceneKitAssets;
			_CompileColladaAssets;
			_CompileTextureAtlases;
			_CompileCoreMLModels;
		</_CollectBundleResourcesDependsOn>
	</PropertyGroup>

	<Target Name="_CollectBundleResources" DependsOnTargets="$(_CollectBundleResourcesDependsOn)">
		<!-- For multi-RID builds, we first build once for each RuntimeIdentifier, then build again to create a universal app bundle.
		     In the case of resources, it's wasteful to build them multiple times, so we hoist it out to the outer build, and store the
		     list of resources we've procesed in _Processed*Path. Here we load that file, and remove them from the item group with the resources -->
		<ReadItemsFromFile File="$(_ProcessedBundleResourcesPath)" Condition="Exists('$(_ProcessedBundleResourcesPath)')">
			<Output TaskParameter="Items" ItemName="_ProcessedBundleResources" />
		</ReadItemsFromFile>
		<ReadItemsFromFile File="$(_ProcessedContentPath)" Condition="Exists('$(_ProcessedContentPath)')">
			<Output TaskParameter="Items" ItemName="_ProcessedContent" />
		</ReadItemsFromFile>
		<ItemGroup>
			<BundleResource Remove="@(_ProcessedBundleResources)" />
			<Content Remove="@(_ProcessedContent)" />
		</ItemGroup>

		<CollectBundleResources
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			OptimizePropertyLists="$(OptimizePropertyLists)"
			OptimizePNGs="$(OptimizePNGs)"
			BundleResources="@(Content);@(BundleResource)"
			ProjectDir="$(MSBuildProjectDirectory)"
			ResourcePrefix="$(_ResourcePrefix)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
			>
			<Output TaskParameter="BundleResourcesWithLogicalNames" ItemName="_BundleResourceWithLogicalName" />
		</CollectBundleResources>

		<!-- Write out the list of assets we've processed, so that an inner build in a multi-rid build can skip processing them -->
		<WriteItemsToFile Items="@(BundleResource)" Condition="'$(_SaveProcessedItems)' == 'true'" ItemName="BundleResource" File="$(_ProcessedBundleResourcesPath)" Overwrite="true" IncludeMetadata="false" />
		<WriteItemsToFile Items="@(Content)" Condition="'$(_SaveProcessedItems)' == 'true'" ItemName="Content" File="$(_ProcessedContentPath)" Overwrite="true" IncludeMetadata="false" />
		<ItemGroup>
			<FileWrites Include="$(_ProcessedBundleResourcesPath)" />
			<FileWrites Include="$(_ProcessedContentPath)" />
		</ItemGroup>

		<!-- Copy any items with the PublishFolderType metadata directly to the ResolvedFileToPublish item group -->
		<ItemGroup>
			<ResolvedFileToPublish Include="@(BundleResource)" Condition="'%(BundleResource.PublishFolderType)' != ''" />
			<ResolvedFileToPublish Include="@(Content)" Condition="'%(Content.PublishFolderType)' != ''" />
		</ItemGroup>
	</Target>

	<!--

	The process to create the final app manifest (aka Info.plist) is a bit convoluted.

		1. The user can specify values in multiple ways:

		    * An Info.plist in their project file (by using a `None` item with filename "Info.plist" or with a `Link` metadata with filename "Info.plist"). We figure this out in the DetectAppManifest target.
		    * A partial plist in their project (using the `PartialAppManifest` item group). Developers can add targets to the public CollectAppManifestsDependsOn
		      property to run targets that add to the `PartialAppManifest` item group before we process them.
		    * Some MSBuild properties can also add values.

		    The precedence is: MSBuild properties can be overridden by the Info.plist, which can be overridden by a partial plist.

		2. In the `CompileAppManifest` target we get all the inputs from above, and compute a temporary app manifest, which is written to a temporary output file.

		3. In the `ReadAppManifest` target, we read the temporary output file and outputs numerous MSBuild properties (most of then private)

		4. We run some other tasks, that depend on the values from `ReadAppManifest`, and adds more entries that should be in the final app manifest. These are written to partial plists, and added to the _PostCompilePartialAppManifest item group.
			* _CompileImageAssets
			* _CompileCoreMLModels

		5. In the `WriteAppManifest` target, we read the temporary output file from `ReadAppManifest` + any `_PartialAppManfiest` items and merge them all together to get the final Info.plist.

	-->

	<PropertyGroup>
		<_CompileAppManifestDependsOn>
			CollectAppManifests;
			$(_CompileAppManifestDependsOn);
			_DetectAppManifest;
			_DetectSdkLocations;
			_GenerateBundleName;
			_ComputeTargetFrameworkMoniker;
			_ComputeTargetArchitectures;
		</_CompileAppManifestDependsOn>
	</PropertyGroup>

	<!-- This is a public target that collects all the (partial) app manifests. The recommended way to make sure all
		 the desired entries are added to PartialAppManifest is to add the target that adds to PartialAppManifest
		 to the CollectAppManifestsDependsOn property. -->
	<Target Name="CollectAppManifests" DependsOnTargets="$(CollectAppManifestsDependsOn)" />

	<!-- This target has no inputs, because it must still be run if there are no input app manifests, to set default values -->
	<Target Name="_CompileAppManifest"
		DependsOnTargets="$(_CompileAppManifestDependsOn)"
		Outputs="$(_TemporaryAppManifest)"
		>

		<ItemGroup>
			<_FontFilesToRegister Include="@(BundleResource)" Condition="'%(BundleResource.RegisterFont)' == 'true'" />
		</ItemGroup>

		<CompileAppManifest
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			ApplicationId="$(ApplicationId)"
			ApplicationTitle="$(ApplicationTitle)"
			ApplicationVersion="$(ApplicationVersion)"
			ApplicationDisplayVersion="$(ApplicationDisplayVersion)"
			AppBundleName="$(_AppBundleName)"
			AppManifest="$(AppBundleManifest)"
			AssemblyName="$(AssemblyName)"
			CompiledAppManifest="$(_TemporaryAppManifest)"
			Debug="$(_BundlerDebug)"
			DefaultSdkVersion="$(_SdkVersion)"
			FontFilesToRegister="@(_FontFilesToRegister)"
			GenerateApplicationManifest="$(GenerateApplicationManifest)"
			IsAppExtension="$(IsAppExtension)"
			IsWatchApp="$(IsWatchApp)"
			IsWatchExtension="$(IsWatchExtension)"
			IsXPCService="$(IsXPCService)"
			PartialAppManifests="@(PartialAppManifest)"
			ProjectDir="$(MSBuildProjectDirectory)"
			ResourcePrefix="$(_ResourcePrefix)"
			ResourceRules="$(_PreparedResourceRules)"
			TargetArchitectures="$(TargetArchitectures)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
			SdkPlatform="$(_SdkPlatform)"
			SdkIsSimulator="$(_SdkIsSimulator)"
			SdkVersion="$(_SdkVersion)"
			SupportedOSPlatformVersion="$(SupportedOSPlatformVersion)"
			DebugIPAddresses="$(_DebugIPAddresses)"
			Validate="$(_CreateAppManifest)"
			>
		</CompileAppManifest>
	</Target>

	<PropertyGroup>
		<_ReadAppManifestDependsOn>
			$(_ReadAppManifestDependsOn);
			_DetectAppManifest;
			_DetectSdkLocations;
			_CompileAppManifest;
			_ComputeTargetFrameworkMoniker;
		</_ReadAppManifestDependsOn>
	</PropertyGroup>

	<Target Name="_ReadAppManifest" DependsOnTargets="$(_ReadAppManifestDependsOn)">
		<ReadAppManifest
			Condition="'$(IsMacEnabled)' == 'true'"
			SessionId="$(BuildSessionId)"
			AppManifest="$(_TemporaryAppManifest)"
			SdkVersion="$(_SdkVersion)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
			>
			<Output TaskParameter="CFBundleExecutable" PropertyName="_ExecutableName" />
			<Output TaskParameter="CFBundleDisplayName" PropertyName="_CFBundleDisplayName" />
			<Output TaskParameter="CFBundleIdentifier" PropertyName="_BundleIdentifier" />
			<Output TaskParameter="CFBundleVersion" PropertyName="_CFBundleVersion" />
			<Output TaskParameter="CLKComplicationGroup" PropertyName="_CLKComplicationGroup" />
			<Output TaskParameter="MinimumOSVersion" PropertyName="_MinimumOSVersion" />
			<Output TaskParameter="NSExtensionPointIdentifier" PropertyName="_NSExtensionPointIdentifier" />
			<Output TaskParameter="UIDeviceFamily" PropertyName="_UIDeviceFamily" />
			<Output TaskParameter="WKWatchKitApp" PropertyName="_WKWatchKitApp" />
			<Output TaskParameter="XSAppIconAssets" PropertyName="_XSAppIconAssets" />
			<Output TaskParameter="XSLaunchImageAssets" PropertyName="_XSLaunchImageAssets" />
		</ReadAppManifest>
	</Target>

	<PropertyGroup>
		<_WriteAppManifestDependsOn>
			_CompileAppManifest;
			_CompileImageAssets;
			_CompileCoreMLModels;
		</_WriteAppManifestDependsOn>
	</PropertyGroup>

	<!-- This target will create the $(_AppBundleManifestPath) file - any task that takes $(_AppBundleManifestPath) must depend on this target -->
	<Target Name="_WriteAppManifest"
		Condition="'$(_CreateAppManifest)' == 'true'"
		DependsOnTargets="$(_WriteAppManifestDependsOn)"
		Inputs="@(_PostCompilePartialAppManifest);$(_TemporaryAppManifest)"
		Outputs="$(_AppBundleManifestPath)"
		>

		<WriteAppManifest
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			AppBundleManifest="$(_AppBundleManifestPath)"
			AppManifests="@(_PostCompilePartialAppManifest);$(_TemporaryAppManifest)"
			>
		</WriteAppManifest>

		<RemoveDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Directories="$(AppBundleDir).dSYM" />
		<Delete SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Files="$(DeviceSpecificOutputPath)*.bcsymbolmap" />
	</Target>

	<PropertyGroup>
		<_CompileEntitlementsDependsOn>
			$(_CompileEntitlementsDependsOn);
			_DetectSdkLocations;
			_GenerateBundleName;
			_DetectSigningIdentity;
			_ComputeTargetFrameworkMoniker;
			_ReadAppManifest;
		</_CompileEntitlementsDependsOn>
	</PropertyGroup>

	<Target Name="_CompileEntitlements"
		Condition="'$(_RequireCodeSigning)' == 'true' Or ('$(CodesignEntitlements)' != '' And '$(_PlatformName)' != 'macOS')"
		DependsOnTargets="$(_CompileEntitlementsDependsOn)"
		Outputs="$(DeviceSpecificIntermediateOutputPath)Entitlements.xcent">
		<CompileEntitlements
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			AppBundleDir="$(AppBundleDir)"
			AppIdentifier="$(_AppIdentifier)"
			BundleIdentifier="$(_BundleIdentifier)"
			Entitlements="$(CodesignEntitlements)"
			CompiledEntitlements="$(DeviceSpecificIntermediateOutputPath)Entitlements.xcent"
			IsAppExtension="$(IsAppExtension)"
			ProvisioningProfile="$(_ProvisioningProfile)"
			SdkIsSimulator="$(_SdkIsSimulator)"
			SdkPlatform="$(_SdkPlatform)"
			SdkVersion="$(_SdkVersion)"
			SdkDevPath="$(_SdkDevPath)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
			Debug="$(_BundlerDebug)"
			>

			<!-- $(_CompiledEntitlements) will be passed to the MTouch task, it's used to embed the entitlements in the executable -->
			<Output TaskParameter="EntitlementsInExecutable" PropertyName="_CompiledEntitlements" />

			<!-- $(_CompiledCodesignEntitlements) will be used only with Codesign tasks when building for device. MUST NOT BE SET for iOS Simulator builds. -->
			<Output TaskParameter="EntitlementsInSignature" PropertyName="_CompiledCodesignEntitlements" />
		</CompileEntitlements>
	</Target>

	<!-- Compilation of InterfaceDefinition assets (*.xib, *.storyboard) -->

	<PropertyGroup>
		<_CompileInterfaceDefinitionsDependsOn>
			$(_CompileInterfaceDefinitionsDependsOn);
			_DetectAppManifest;
			_DetectSdkLocations;
			_ComputeTargetArchitectures;
			_RemoveProcessedInterfaceDefinitions;
			_BeforeCoreCompileInterfaceDefinitions;
			_ReadCoreCompileInterfaceDefinitions;
			_CoreCompileInterfaceDefinitions;
		</_CompileInterfaceDefinitionsDependsOn>
	</PropertyGroup>

	<Target Name="_CompileInterfaceDefinitions" DependsOnTargets="$(_CompileInterfaceDefinitionsDependsOn)" />

	<!-- For multi-RID builds, we first build once for each RuntimeIdentifier, then build again to create a universal app bundle.
	     In the case of resources, it's wasteful to build them multiple times, so we hoist it out to the outer build, and store the
	     list of resources we've procesed in _Processed*Path. Here we load that file, and remove them from the item group with the resources -->
	<Target Name="_RemoveProcessedInterfaceDefinitions" Condition="Exists('$(_ProcessedInterfaceDefinitionsPath)')">
		<ReadItemsFromFile File="$(_ProcessedInterfaceDefinitionsPath)">
			<Output TaskParameter="Items" ItemName="_ProcessedInterfaceDefinitions" />
		</ReadItemsFromFile>

		<ItemGroup>
			<InterfaceDefinition Remove="@(_ProcessedInterfaceDefinitions)" />
		</ItemGroup>
	</Target>

	<Target Name="_BeforeCoreCompileInterfaceDefinitions"
		Inputs="@(InterfaceDefinition)"
		Outputs="$(_IBToolCache)">

		<!-- If any InterfaceDefinition is newer than the generated items list, we delete them so that the _CoreCompileInterfaceDefinitions 
		     target runs again and updates those lists for the next run
		-->
		<Delete Files="$(_IBToolCache)" />
	</Target>

	<Target Name="_ReadCoreCompileInterfaceDefinitions"	DependsOnTargets="_BeforeCoreCompileInterfaceDefinitions">
		<!-- If _BeforeCoreCompileInterfaceDefinitions did not delete the generated items lists from _CoreCompileInterfaceDefinitions, then we read them
		     since that target won't run and we need to the output items that are cached in those files which includes full metadata -->
		<ReadItemsFromFile File="$(_IBToolCache)" Condition="Exists('$(_IBToolCache)')">
			<Output TaskParameter="Items" ItemName="_BundleResourceWithLogicalName" />
		</ReadItemsFromFile>
	</Target>

	<PropertyGroup>
		<_CoreCompileInterfaceDefinitionsDependsOn>
			_BeforeCoreCompileInterfaceDefinitions;
			_ReadAppManifest;
			_DetectSigningIdentity;
			_ComputeTargetFrameworkMoniker;
		</_CoreCompileInterfaceDefinitionsDependsOn>
	</PropertyGroup>

	<Target Name="_CoreCompileInterfaceDefinitions"
		Inputs="@(InterfaceDefinition)"
		Outputs="$(_IBToolCache)"
		DependsOnTargets="$(_CoreCompileInterfaceDefinitionsDependsOn)">

		<IBTool
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			ToolExe="$(IBToolExe)"
			ToolPath="$(IBToolPath)"
			BundleIdentifier="$(_BundleIdentifier)"
			CLKComplicationGroup="$(_CLKComplicationGroup)"
			EnableOnDemandResources="$(EnableOnDemandResources)"
			InterfaceDefinitions="@(InterfaceDefinition)"
			IntermediateOutputPath="$(DeviceSpecificIntermediateOutputPath)"
			MinimumOSVersion="$(_MinimumOSVersion)"
			NSExtensionPointIdentifier="$(_NSExtensionPointIdentifier)"
			IsWatchApp="$(IsWatchApp)"
			IsWatch2App="$(IsWatch2App)"
			ProjectDir="$(MSBuildProjectDirectory)"
			ResourcePrefix="$(_ResourcePrefix)"
			SdkDevPath="$(_SdkDevPath)"
			SdkBinPath="$(_SdkBinPath)"
			SdkUsrPath="$(_SdkUsrPath)"
			SdkRoot="$(_SdkRoot)"
			SdkPlatform="$(_SdkPlatform)"
			SdkVersion="$(_SdkVersion)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
			UIDeviceFamily="$(_UIDeviceFamily)"
			WKWatchKitApp="$(_WKWatchKitApp)"
			XSAppIconAssets="$(_XSAppIconAssets)"
			XSLaunchImageAssets="$(_XSLaunchImageAssets)"
			>
			<Output TaskParameter="BundleResources" ItemName="_BundleResourceWithLogicalName" />

			<!-- Local items to be persisted to items files -->
			<Output TaskParameter="BundleResources" ItemName="_IBTool_BundleResources" />
		</IBTool>

		<!-- Cached the generated outputs items for incremental build support -->
		<WriteItemsToFile Items="@(_IBTool_BundleResources)" ItemName="_BundleResourceWithLogicalName" File="$(_IBToolCache)" Overwrite="true" IncludeMetadata="true" />
		<!-- Write out the list of assets we've processed, so that an inner build in a multi-rid build can skip processing them -->
		<WriteItemsToFile Items="@(InterfaceDefinition)" Condition="'$(_SaveProcessedItems)' == 'true'" ItemName="InterfaceDefinition" File="$(_ProcessedInterfaceDefinitionsPath)" Overwrite="true" IncludeMetadata="false" />

		<ItemGroup>
			<FileWrites Include="$(_IBToolCache)" />
			<FileWrites Include="$(_ProcessedInterfaceDefinitionsPath)" />
		</ItemGroup>
	</Target>

	<!-- Compilation of ImageAsset items -->

	<PropertyGroup>
		<_CompileImageAssetsDependsOn>
			$(_CompileImageAssetsDependsOn);
			_DetectAppManifest;
			_DetectSdkLocations;
			_ComputeTargetArchitectures;
			_RemoveProcessedImageAssets;
			_BeforeCoreCompileImageAssets;
			_ReadCompileImageAssets;
			_CoreCompileImageAssets;
		</_CompileImageAssetsDependsOn>
	</PropertyGroup>

	<Target Name="_CompileImageAssets" DependsOnTargets="$(_CompileImageAssetsDependsOn)" />

	<!-- For multi-RID builds, we first build once for each RuntimeIdentifier, then build again to create a universal app bundle.
	     In the case of resources, it's wasteful to build them multiple times, so we hoist it out to the outer build, and store the
	     list of resources we've procesed in _Processed*Path. Here we load that file, and remove them from the item group with the resources -->
	<Target Name="_RemoveProcessedImageAssets" Condition="Exists('$(_ProcessedImageAssetsPath)')">
		<ReadItemsFromFile File="$(_ProcessedImageAssetsPath)">
			<Output TaskParameter="Items" ItemName="_ProcessedImageAssets" />
		</ReadItemsFromFile>

		<ItemGroup>
			<ImageAsset Remove="@(_ProcessedImageAssets)" />
		</ItemGroup>
	</Target>

	<Target Name="_BeforeCoreCompileImageAssets"
		Inputs="@(ImageAsset);$(_TemporaryAppManifest)"
		Outputs="$(_ACTool_PartialAppManifestCache);$(_ACTool_BundleResourceCache)"
		DependsOnTargets="_ReadAppManifest"
		>

		<!-- If any ImageAsset or AppManifest is newer than the generated items list, we delete them so that the _CoreCompileImageAssets
		     target runs again and updates those lists for the next run
		-->
		<Delete Files="$(_ACTool_PartialAppManifestCache);$(_ACTool_BundleResourceCache)" />
		<RemoveDir Directories="$(DeviceSpecificIntermediateOutputPath)actool" />
	</Target>

	<Target Name="_ReadCompileImageAssets"
		DependsOnTargets="_BeforeCoreCompileImageAssets">

		<!-- If _BeforeCoreCompileImageAssets did not delete the generated items lists from _CoreCompileImageAsset, then we read them
		     since that target won't run and we need the output items that are cached in those files, which includes full metadata -->
		<ReadItemsFromFile File="$(_ACTool_PartialAppManifestCache)" Condition="Exists('$(_ACTool_PartialAppManifestCache)')">
			<Output TaskParameter="Items" ItemName="_PostCompilePartialAppManifest" />
		</ReadItemsFromFile>
		<ReadItemsFromFile File="$(_ACTool_BundleResourceCache)" Condition="Exists('$(_ACTool_BundleResourceCache)')">
			<Output TaskParameter="Items" ItemName="_BundleResourceWithLogicalName" />
		</ReadItemsFromFile>
	</Target>

	<PropertyGroup>
		<_CoreCompileImageAssetsDependsOn>
			$(_CoreCompileImageAssets);
			_ReadAppManifest;
			_DetectSdkLocations;
			_BeforeCoreCompileImageAssets;
			_DetectSigningIdentity;
			_ComputeTargetFrameworkMoniker;
		</_CoreCompileImageAssetsDependsOn>
	</PropertyGroup>

	<Target Name="_CoreCompileImageAssets"
		Inputs="@(ImageAsset);$(_TemporaryAppManifest)"
		Outputs="$(_ACTool_PartialAppManifestCache);$(_ACTool_BundleResourceCache)"
		DependsOnTargets="$(_CoreCompileImageAssetsDependsOn)">

		<ACTool
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '@(ImageAsset)' != ''"
			ToolExe="$(ACToolExe)"
			ToolPath="$(ACToolPath)"
			BundleIdentifier="$(_BundleIdentifier)"
			CLKComplicationGroup="$(_CLKComplicationGroup)"
			DeviceModel="$(TargetDeviceModel)"
			DeviceOSVersion="$(TargetDeviceOSVersion)"
			EnableOnDemandResources="$(EnableOnDemandResources)"
			ImageAssets="@(ImageAsset)"
			MinimumOSVersion="$(_MinimumOSVersion)"
			NSExtensionPointIdentifier="$(_NSExtensionPointIdentifier)"
			OptimizePNGs="$(OptimizePNGs)"
			OutputPath="$(DeviceSpecificOutputPath)"
			IntermediateOutputPath="$(DeviceSpecificIntermediateOutputPath)"
			IsWatchApp="$(IsWatchApp)"
			ProjectDir="$(MSBuildProjectDirectory)"
			ResourcePrefix="$(_ResourcePrefix)"
			SdkDevPath="$(_SdkDevPath)"
			SdkBinPath="$(_SdkBinPath)"
			SdkUsrPath="$(_SdkUsrPath)"
			SdkPlatform="$(_SdkPlatform)"
			SdkVersion="$(_SdkVersion)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
			UIDeviceFamily="$(_UIDeviceFamily)"
			WKWatchKitApp="$(_WKWatchKitApp)"
			XSAppIconAssets="$(_XSAppIconAssets)"
			XSLaunchImageAssets="$(_XSLaunchImageAssets)"
			>
			<Output TaskParameter="PartialAppManifest" ItemName="_PostCompilePartialAppManifest" />
			<Output TaskParameter="BundleResources" ItemName="_BundleResourceWithLogicalName" />

			<!-- Local items to be persisted to items files -->
			<Output TaskParameter="PartialAppManifest" ItemName="_ACTool_PartialAppManifest" />
			<Output TaskParameter="BundleResources" ItemName="_ACTool_BundleResources" />
		</ACTool>

		<!-- Cache the generated outputs items for incremental build support -->
		<WriteItemsToFile Items="@(_ACTool_PartialAppManifest)" ItemName="_PostCompilePartialAppManifest" File="$(_ACTool_PartialAppManifestCache)" Overwrite="true" IncludeMetadata="true" />
		<WriteItemsToFile Items="@(_ACTool_BundleResources)" ItemName="_BundleResourceWithLogicalName" File="$(_ACTool_BundleResourceCache)" Overwrite="true" IncludeMetadata="true" />
		<!-- Write out the list of assets we've processed, so that an inner build in a multi-rid build can skip processing them -->
		<WriteItemsToFile Items="@(ImageAsset)" Condition="'$(_SaveProcessedItems)' == 'true'" ItemName="ImageAsset" File="$(_ProcessedImageAssetsPath)" Overwrite="true" IncludeMetadata="false" />
		<ItemGroup>
			<FileWrites Include="$(_ACTool_PartialAppManifestCache);$(_ACTool_BundleResourceCache)" />
			<FileWrites Include="$(_ProcessedImageAssetsPath)" />
		</ItemGroup>
	</Target>

	<!-- Compilation of SceneKit assets -->

	<PropertyGroup>
		<_CompileSceneKitAssetsDependsOn>
			$(_CompileSceneKitAssetsDependsOn);
			_DetectAppManifest;
			_DetectSdkLocations;
			_ComputeTargetArchitectures;
			_RemoveProcessedSceneKitAssets;
			_BeforeCoreCompileSceneKitAssets;
			_ReadCoreCompileSceneKitAssets;
			_CoreCompileSceneKitAssets;
		</_CompileSceneKitAssetsDependsOn>
	</PropertyGroup>

	<Target Name="_CompileSceneKitAssets" DependsOnTargets="$(_CompileSceneKitAssetsDependsOn)" />

	<!-- For multi-RID builds, we first build once for each RuntimeIdentifier, then build again to create a universal app bundle.
	     In the case of resources, it's wasteful to build them multiple times, so we hoist it out to the outer build, and store the
	     list of resources we've procesed in _Processed*Path. Here we load that file, and remove them from the item group with the resources -->
	<Target Name="_RemoveProcessedSceneKitAssets" Condition="Exists('$(_ProcessedSceneKitAssetsPath)')">
		<ReadItemsFromFile File="$(_ProcessedSceneKitAssetsPath)">
			<Output TaskParameter="Items" ItemName="_ProcessedSceneKitAssets" />
		</ReadItemsFromFile>

		<ItemGroup>
			<SceneKitAsset Remove="@(_ProcessedSceneKitAssets)" />
		</ItemGroup>
	</Target>

	<Target Name="_BeforeCoreCompileSceneKitAssets"
		Inputs="@(SceneKitAsset)"
		Outputs="$(_SceneKitCache)">

		<!-- If any SceneKitAsset is newer than the generated items list, we delete them so that the _CoreCompileSceneKitAssets 
		     target runs again and updates those lists for the next run
		-->
		<Delete Files="$(_SceneKitCache)" />
	</Target>

	<Target Name="_ReadCoreCompileSceneKitAssets"
		DependsOnTargets="_BeforeCoreCompileSceneKitAssets">

		<!-- If _BeforeCoreCompileSceneKitAssets did not delete the generated items lists from _CoreCompileSceneKitAssets, then we read them
		     since that target won't run and we need to the output items that are cached in those files which includes full metadata -->
		<ReadItemsFromFile File="$(_SceneKitCache)" Condition="Exists('$(_SceneKitCache)')">
			<Output TaskParameter="Items" ItemName="_BundleResourceWithLogicalName" />
		</ReadItemsFromFile>
	</Target>

	<Target Name="_CoreCompileSceneKitAssets"
		Inputs="@(SceneKitAsset)"
		Outputs="$(_SceneKitCache)"
		DependsOnTargets="_BeforeCoreCompileSceneKitAssets;_GenerateBundleName;_ComputeTargetFrameworkMoniker">

		<CompileSceneKitAssets
			SessionId="$(BuildSessionId)"
			AppBundleName="$(_AppBundleName)$(AppBundleExtension)"
			Condition="'$(IsMacEnabled)' == 'true'"
			ToolExe="$(CopySceneKitAssetsExe)"
			ToolPath="$(CopySceneKitAssetsPath)"
			SceneKitAssets="@(SceneKitAsset)"
			IntermediateOutputPath="$(DeviceSpecificIntermediateOutputPath)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
			ProjectDir="$(MSBuildProjectDirectory)"
			ResourcePrefix="$(_ResourcePrefix)"
			IsWatchApp="$(IsWatchApp)"
			SdkPlatform="$(_SdkPlatform)"
			SdkDevPath="$(_SdkDevPath)"
			SdkRoot="$(_SdkRoot)"
			SdkVersion="$(_SdkVersion)">
			<Output TaskParameter="BundleResources" ItemName="_BundleResourceWithLogicalName" />

			<!-- Local items to be persisted to items files -->
			<Output TaskParameter="BundleResources" ItemName="_SceneKitAssets_BundleResources" />
		</CompileSceneKitAssets>

		<WriteItemsToFile Items="@(_SceneKitAssets_BundleResources)" ItemName="_BundleResourceWithLogicalName" File="$(_SceneKitCache)" Overwrite="true" IncludeMetadata="true" />
		<!-- Write out the list of assets we've processed, so that an inner build in a multi-rid build can skip processing them -->
		<WriteItemsToFile Items="@(SceneKitAsset)" Condition="'$(_SaveProcessedItems)' == 'true'" ItemName="SceneKitAsset" File="$(_ProcessedSceneKitAssetsPath)" Overwrite="true" IncludeMetadata="false" />
		<ItemGroup>
			<FileWrites Include="$(_SceneKitCache)" />
			<FileWrites Include="$(_ProcessedSceneKitAssetsPath)" />
		</ItemGroup>
	</Target>

	<!-- Collada assets -->

	<PropertyGroup>
		<CompileColladaAssetsDependsOn>
			_RemoveProcessedColladaAssets;
			_CollectColladaAssets;
			_CoreCompileColladaAssets
		</CompileColladaAssetsDependsOn>
	</PropertyGroup>

	<Target Name="_CompileColladaAssets" Condition="'$(_CanOutputAppBundle)' == 'true'" DependsOnTargets="$(CompileColladaAssetsDependsOn)" />

	<!-- For multi-RID builds, we first build once for each RuntimeIdentifier, then build again to create a universal app bundle.
	     In the case of resources, it's wasteful to build them multiple times, so we hoist it out to the outer build, and store the
	     list of resources we've procesed in _Processed*Path. Here we load that file, and remove them from the item group with the resources -->
	<Target Name="_RemoveProcessedColladaAssets" Condition="Exists('$(_ProcessedColladaAssetsPath)')">
		<ReadItemsFromFile File="$(_ProcessedColladaAssetsPath)">
			<Output TaskParameter="Items" ItemName="_ProcessedColladaAssets" />
		</ReadItemsFromFile>

		<ItemGroup>
			<Collada Remove="@(_ProcessedColladaAssets)" />
		</ItemGroup>
	</Target>

	<Target Name="_CollectColladaAssets">
		<CollectBundleResources
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			BundleResources="@(Collada)"
			ProjectDir="$(MSBuildProjectDirectory)"
			ResourcePrefix="$(_ResourcePrefix)">
			<Output TaskParameter="BundleResourcesWithLogicalNames" ItemName="_ColladaAssetWithLogicalName" />
		</CollectBundleResources>
	</Target>

	<Target Name="_CoreCompileColladaAssets"
		DependsOnTargets="_CollectColladaAssets;_DetectSdkLocations;_ComputeTargetFrameworkMoniker"
		Inputs="@(_ColladaAssetWithLogicalName)"
		Outputs="$(DeviceSpecificIntermediateOutputPath)%(_ColladaAssetWithLogicalName.LogicalName)"
		>

		<ScnTool
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			IsWatchApp="$(IsWatchApp)"
			ToolExe="$(ScnToolExe)"
			ToolPath="$(ScnToolPath)"
			SdkPlatform="$(_SdkPlatform)"
			SdkRoot="$(_SdkRoot)"
			SdkDevPath="$(_SdkDevPath)"
			SdkVersion="$(_SdkVersion)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
			IntermediateOutputPath="$(DeviceSpecificIntermediateOutputPath)"
			InputScene="%(_ColladaAssetWithLogicalName.Identity)"
			OutputScene="$(DeviceSpecificIntermediateOutputPath)%(_ColladaAssetWithLogicalName.LogicalName)">
		</ScnTool>

		<CreateItem Include="$(DeviceSpecificIntermediateOutputPath)%(_ColladaAssetWithLogicalName.LogicalName)" AdditionalMetadata="LogicalName=%(_ColladaAssetWithLogicalName.LogicalName);Optimize='False'">
			<Output TaskParameter="Include" ItemName="_BundleResourceWithLogicalName" />
		</CreateItem>

		<!-- Write out the list of assets we've processed, so that an inner build in a multi-rid build can skip processing them -->
		<WriteItemsToFile Items="@(_ColladaAssetWithLogicalName)" Condition="'$(_SaveProcessedItems)' == 'true'" ItemName="_ColladaAssetWithLogicalName" File="$(_ProcessedColladaAssetsPath)" Overwrite="true" IncludeMetadata="false" />
		<ItemGroup>
			<FileWrites Include="$(_ProcessedColladaAssetsPath)" />
		</ItemGroup>
	</Target>

	<PropertyGroup>
		<_ComputeTargetArchitecturesDependsOn>
			$(_ComputeTargetArchitecturesDependsOn);
			_ComputeTargetFrameworkMoniker;
		</_ComputeTargetArchitecturesDependsOn>
	</PropertyGroup>

	<Target Name="_ComputeTargetArchitectures" DependsOnTargets="$(_ComputeTargetArchitecturesDependsOn)">
		<!--
			For now, this target is mostly for Xamarin.iOS, but in order to
			use the same variables elsewhere, we have code for Xamarin.Mac
			that outputs the same variables. However, as build logic between
			Xamarin.iOS and Xamarin.Mac converges, more and more of this logic
			will apply to Xamarin.Mac as well.
		-->
		<ParseDeviceSpecificBuildInformation
			SessionId="$(BuildSessionId)"
			Condition="'$(DeviceSpecificBuild)' == 'true' And '$(TargetiOSDevice)' != '' And '$(_CanDeployToDeviceOrSimulator)' == 'true' And '$(_PlatformName)' != 'macOS'"
			Architectures="$(TargetArchitectures)"
			IntermediateOutputPath="$(IntermediateOutputPath)"
			OutputPath="$(OutputPath)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
			TargetiOSDevice="$(TargetiOSDevice)"
		>
			<Output TaskParameter="DeviceSpecificIntermediateOutputPath" PropertyName="DeviceSpecificIntermediateOutputPath" />
			<Output TaskParameter="DeviceSpecificOutputPath" PropertyName="DeviceSpecificOutputPath" />
			<Output TaskParameter="TargetArchitectures" PropertyName="TargetArchitectures" />
			<Output TaskParameter="TargetDeviceModel" PropertyName="TargetDeviceModel" />
			<Output TaskParameter="TargetDeviceOSVersion" PropertyName="TargetDeviceOSVersion" />
		</ParseDeviceSpecificBuildInformation>

		<PropertyGroup>
			<_MtouchSymbolsList>$(DeviceSpecificIntermediateOutputPath)mtouch-symbols.list</_MtouchSymbolsList>

			<!-- actool output caches -->
			<_ACTool_PartialAppManifestCache>$(DeviceSpecificIntermediateOutputPath)actool\_PartialAppManifest.items</_ACTool_PartialAppManifestCache>
			<_ACTool_BundleResourceCache>$(DeviceSpecificIntermediateOutputPath)actool\_BundleResourceWithLogicalName.items</_ACTool_BundleResourceCache>

			<!-- coremlc output caches -->
			<_CoreMLModel_PartialAppManifestCache>$(DeviceSpecificIntermediateOutputPath)coremlc\_PartialAppManifest.items</_CoreMLModel_PartialAppManifestCache>
			<_CoreMLModel_BundleResourceCache>$(DeviceSpecificIntermediateOutputPath)coremlc\_BundleResourceWithLogicalName.items</_CoreMLModel_BundleResourceCache>

			<!-- ibtool output caches -->
			<_IBToolCache>$(DeviceSpecificIntermediateOutputPath)ibtool\_BundleResourceWithLogicalName.items</_IBToolCache>

			<!-- scntool output caches -->
			<_SceneKitCache>$(DeviceSpecificIntermediateOutputPath)copySceneKitAssets\_BundleResourceWithLogicalName.items</_SceneKitCache>

			<!-- TextureAtlas output caches -->
			<_TextureAtlasCache>$(DeviceSpecificIntermediateOutputPath)atlas\_BundleResourceWithLogicalName.items</_TextureAtlasCache>

			<!-- processed items -->
			<_ProcessedBundleResourcesPath Condition="'$(_ProcessedBundleResourcesPath)' == ''">$(DeviceSpecificIntermediateOutputPath)\_ProcessedBundleResourcesPath.items</_ProcessedBundleResourcesPath>
			<_ProcessedContentPath Condition="'$(_ProcessedContentPath)' == ''">$(DeviceSpecificIntermediateOutputPath)\_ProcessedContentPath.items</_ProcessedContentPath>
			<_ProcessedImageAssetsPath Condition="'$(_ProcessedImageAssetsPath)' == ''">$(DeviceSpecificIntermediateOutputPath)actool\_ProcessedImageAssetsPath.items</_ProcessedImageAssetsPath>
			<_ProcessedInterfaceDefinitionsPath Condition="'$(_ProcessedInterfaceDefinitionsPath)' == ''">$(DeviceSpecificIntermediateOutputPath)ibtool\_ProcessedInterfaceDefinitionsPath.items</_ProcessedInterfaceDefinitionsPath>
			<_ProcessedSceneKitAssetsPath Condition="'$(_ProcessedSceneKitAssetsPath)' == ''">$(DeviceSpecificIntermediateOutputPath)copySceneKitAssets\_ProcessedSceneKitAssetsPath.items</_ProcessedSceneKitAssetsPath>
			<_ProcessedColladaAssetsPath Condition="'$(_ProcessedColladaAssetsPath)' == ''">$(DeviceSpecificIntermediateOutputPath)collada\_ProcessedColladaAssetsPath.items</_ProcessedColladaAssetsPath>
			<_ProcessedTextureAtlasesPath Condition="'$(_ProcessedTextureAtlasesPath)' == ''">$(DeviceSpecificIntermediateOutputPath)atlas\_ProcessedTextureAtlasesPath.items</_ProcessedTextureAtlasesPath>
			<_ProcessedCoreMLModelsPath Condition="'$(_ProcessedCoreMLModelsPath)' == ''">$(DeviceSpecificIntermediateOutputPath)coremlc\_ProcessedCoreMLModelsPath.items</_ProcessedCoreMLModelsPath>
			<_SaveProcessedItems Condition="'$(RuntimeIdentifiers)' != '' And '$(UsingAppleNETSdk)' == 'true'">true</_SaveProcessedItems>
		</PropertyGroup>
	</Target>

	<!-- TODO: check for duplicate items -->
	<Target Name="_ComputeBundleResourceOutputPaths" DependsOnTargets="_CollectBundleResources;_GenerateBundleName;_DetectSigningIdentity;_ReadAppManifest">
		<ComputeBundleResourceOutputPaths
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			AppResourcesPath="$(_AppResourcesPath)"
			BundleIdentifier="$(_BundleIdentifier)"
			BundleResources="@(_BundleResourceWithLogicalName)"
			EnableOnDemandResources="$(EnableOnDemandResources)"
			IntermediateOutputPath="$(DeviceSpecificIntermediateOutputPath)"
			OutputPath="$(DeviceSpecificOutputPath)"
		>
			<Output TaskParameter="BundleResourcesWithOutputPaths" ItemName="_BundleResourceWithOutputPath"/>
		</ComputeBundleResourceOutputPaths>
	</Target>

	<Target Name="_CopyResourcesToBundle" DependsOnTargets="_ComputeBundleResourceOutputPaths"
		Inputs = "@(_BundleResourceWithOutputPath)"
		Outputs = "@(_BundleResourceWithOutputPath -> '%(OutputPath)')" >
		<SmartCopy
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			SourceFiles = "@(_BundleResourceWithOutputPath)"
			DestinationFiles = "@(_BundleResourceWithOutputPath -> '%(OutputPath)')"
		/>
	</Target>

	<Target Name="_CreateAppBundle" Condition="'$(_CanOutputAppBundle)' == 'true' And '$(IsAppDistribution)' != 'true'" DependsOnTargets="$(CreateAppBundleDependsOn)" />

	<Target Name="_ComputePkgInfoPath" DependsOnTargets="_GenerateBundleName">
		<PropertyGroup>
			<_PkgInfoPath Condition="'$(_PlatformName)' == 'macOS' Or '$(_PlatformName)' == 'MacCatalyst'">$(_AppBundlePath)Contents\PkgInfo</_PkgInfoPath>
			<_PkgInfoPath Condition="'$(_PlatformName)' == 'iOS' Or '$(_PlatformName)' == 'tvOS' Or '$(_PlatformName)' == 'watchOS'">$(_AppBundlePath)PkgInfo</_PkgInfoPath>
		</PropertyGroup>
	</Target>

	<Target Name="_CreatePkgInfo" Condition="'$(IsAppExtension)' == 'false'" DependsOnTargets="_ComputePkgInfoPath" Outputs="$(_PkgInfoPath)">
		<CreatePkgInfo SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" OutputPath="$(_PkgInfoPath)" />
	</Target>

	<!-- Compilation of Texture atlases -->

	<PropertyGroup>
		<_CompileTextureAtlasesDependsOn>
			$(_CompileTextureAtlasesDependsOn);
			_DetectSdkLocations;
			_RemoveProcessedTextureAtlases;
			_BeforeCompileTextureAtlases;
			_ReadCoreCompileTextureAtlases;
			_CoreCompileTextureAtlases;
		</_CompileTextureAtlasesDependsOn>
	</PropertyGroup>

	<Target Name="_CompileTextureAtlases" DependsOnTargets="$(_CompileTextureAtlasesDependsOn)" />

	<!-- For multi-RID builds, we first build once for each RuntimeIdentifier, then build again to create a universal app bundle.
	     In the case of resources, it's wasteful to build them multiple times, so we hoist it out to the outer build, and store the
	     list of resources we've procesed in _Processed*Path. Here we load that file, and remove them from the item group with the resources -->
	<Target Name="_RemoveProcessedTextureAtlases" Condition="Exists('$(_ProcessedTextureAtlasesPath)')">
		<ReadItemsFromFile File="$(_ProcessedTextureAtlasesPath)">
			<Output TaskParameter="Items" ItemName="_ProcessedTextureAtlases" />
		</ReadItemsFromFile>

		<ItemGroup>
			<AtlasTexture Remove="@(_ProcessedTextureAtlases)" />
		</ItemGroup>
	</Target>

	<Target Name="_BeforeCompileTextureAtlases"
		Inputs="@(AtlasTexture)"
		Outputs="$(_TextureAtlasCache)">

		<!-- If any AtlasTexture is newer than the generated items list, we delete them so that the _CoreCompileTextureAtlases
		     target runs again and updates those lists for the next run
		-->
		<Delete Files="$(_TextureAtlasCache)" />
	</Target>

	<Target Name="_ReadCoreCompileTextureAtlases"
					DependsOnTargets="_BeforeCompileTextureAtlases">

		<!-- If _BeforeCompileTextureAtlases did not delete the generated items lists from _CoreCompileTextureAtlases, then we read them
		     since that target won't run and we need to the output items that are cached in those files which includes full metadata -->
		<ReadItemsFromFile File="$(_TextureAtlasCache)" Condition="Exists('$(_TextureAtlasCache)')">
			<Output TaskParameter="Items" ItemName="_BundleResourceWithLogicalName" />
		</ReadItemsFromFile>
	</Target>

	<Target Name="_CoreCompileTextureAtlases"
		Inputs="@(AtlasTexture)"
		Outputs="$(_TextureAtlasCache)"
		DependsOnTargets="_BeforeCompileTextureAtlases">

		<TextureAtlas
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			ToolExe="$(TextureAtlasExe)"
			ToolPath="$(TextureAtlasPath)"
			AtlasTextures="@(AtlasTexture)"
			IntermediateOutputPath="$(DeviceSpecificIntermediateOutputPath)"
			ProjectDir="$(MSBuildProjectDirectory)"
			ResourcePrefix="$(_ResourcePrefix)"
			SdkDevPath="$(_SdkDevPath)"
			SdkBinPath="$(_SdkBinPath)"
			SdkUsrPath="$(_SdkUsrPath)">
			<Output TaskParameter="BundleResources" ItemName="_BundleResourceWithLogicalName" />

			<!-- Local items to be persisted to items files -->
			<Output TaskParameter="BundleResources" ItemName="_TextureAtlas_BundleResources" />
		</TextureAtlas>

		<!-- Cached the generated outputs items for incremental build support -->
		<WriteItemsToFile Items="@(_TextureAtlas_BundleResources)" ItemName="_BundleResourceWithLogicalName" File="$(_TextureAtlasCache)" Overwrite="true" IncludeMetadata="true" />
		<!-- Write out the list of assets we've processed, so that an inner build in a multi-rid build can skip processing them -->
		<WriteItemsToFile Items="@(TextureAtlas)" Condition="'$(_SaveProcessedItems)' == 'true'" ItemName="TextureAtlas" File="$(_ProcessedTextureAtlasesPath)" Overwrite="true" IncludeMetadata="false" />
		<ItemGroup>
			<FileWrites Include="$(_TextureAtlasCache)" />
			<FileWrites Include="$(_ProcessedTextureAtlasesPath)" />
		</ItemGroup>
	</Target>

	<!-- Compilation of CoreML models -->

	<PropertyGroup>
		<_CompileCoreMLModelsDependsOn>
			$(_CompileCoreMLModelsDependsOn);
			_DetectAppManifest;
			_DetectSdkLocations;
			_ComputeTargetArchitectures;
			_RemoveProcessedCoreMLModels;
			_BeforeCompileCoreMLModels;
			_ReadCompileCoreMLModels;
			_CoreCompileCoreMLModels;
		</_CompileCoreMLModelsDependsOn>
	</PropertyGroup>

	<Target Name="_CompileCoreMLModels" DependsOnTargets="$(_CompileCoreMLModelsDependsOn)" />

	<!-- For multi-RID builds, we first build once for each RuntimeIdentifier, then build again to create a universal app bundle.
	     In the case of resources, it's wasteful to build them multiple times, so we hoist it out to the outer build, and store the
	     list of resources we've procesed in _Processed*Path. Here we load that file, and remove them from the item group with the resources -->
	<Target Name="_RemoveProcessedCoreMLModels" Condition="Exists('$(_ProcessedCoreMLModelsPath)')">
		<ReadItemsFromFile File="$(_ProcessedCoreMLModelsPath)">
			<Output TaskParameter="Items" ItemName="_ProcessedCoreMLModels" />
		</ReadItemsFromFile>

		<ItemGroup>
			<CoreMLModel Remove="@(_ProcessedCoreMLModels)" />
		</ItemGroup>
	</Target>

	<Target Name="_BeforeCompileCoreMLModels"
		Inputs="@(CoreMLModel);$(_TemporaryAppManifest)"
		Outputs="$(_CoreMLModel_PartialAppManifestCache);$(_CoreMLModel_BundleResourceCache)">
		<!-- If any CoreMLModel or AppManifest is newer than the generated items list, we delete them so that the _CoreCompileCoreMLModels
		     target runs again and updates those lists for the next run
		-->
		<Delete Files="$(_CoreMLModel_PartialAppManifestCache);$(_CoreMLModel_BundleResourceCache)" />
		<RemoveDir Directories="$(DeviceSpecificIntermediateOutputPath)coremlc" />
	</Target>

	<Target Name="_ReadCompileCoreMLModels"	DependsOnTargets="_BeforeCompileCoreMLModels">
		<!-- If _BeforeCompileCoreMLModels did not delete the generated items lists from _CoreCompileCoreMLModels, then we read them
		     since that target won't run and we need the output items that are cached in those files, which includes full metadata -->
		<ReadItemsFromFile File="$(_CoreMLModel_PartialAppManifestCache)" Condition="Exists('$(_CoreMLModel_PartialAppManifestCache)')">
			<Output TaskParameter="Items" ItemName="_PostCompilePartialAppManifest" />
		</ReadItemsFromFile>
		<ReadItemsFromFile File="$(_CoreMLModel_BundleResourceCache)" Condition="Exists('$(_CoreMLModel_BundleResourceCache)')">
			<Output TaskParameter="Items" ItemName="_BundleResourceWithLogicalName" />
		</ReadItemsFromFile>
	</Target>

	<PropertyGroup>
		<_CoreCompileCoreMLModelsDependsOn>
			$(_CoreCompileCoreMLModelsDependsOn);
			_ReadAppManifest;
			_DetectSdkLocations;
			_BeforeCompileCoreMLModels;
		</_CoreCompileCoreMLModelsDependsOn>
	</PropertyGroup>

	<Target Name="_CoreCompileCoreMLModels" 
		Inputs="@(CoreMLModel);$(_TemporaryAppManifest)"
		Outputs="$(_CoreMLModel_PartialAppManifestCache);$(_CoreMLModel_BundleResourceCache)"
		DependsOnTargets="$(_CoreCompileCoreMLModelsDependsOn)">

		<CoreMLCompiler
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			ToolExe="$(CoreMLCompilerExe)"
			ToolPath="$(CoreMLCompilerPath)"
			Models="@(CoreMLModel)"
			EnableOnDemandResources="$(EnableOnDemandResources)"
			IntermediateOutputPath="$(DeviceSpecificIntermediateOutputPath)"
			ProjectDir="$(MSBuildProjectDirectory)"
			ResourcePrefix="$(_ResourcePrefix)"
			SdkDevPath="$(_SdkDevPath)">
			<Output TaskParameter="BundleResources" ItemName="_BundleResourceWithLogicalName" />
			<Output TaskParameter="PartialAppManifests" ItemName="_PostCompilePartialAppManifest" />

			<!-- Local items to be persisted to items files -->
			<Output TaskParameter="PartialAppManifests" ItemName="_CoreMLModel_PartialAppManifest" />
			<Output TaskParameter="BundleResources" ItemName="_CoreMLModel_BundleResources" />
		</CoreMLCompiler>

		<!-- Cache the generated outputs items for incremental build support -->
		<WriteItemsToFile Items="@(_CoreMLModel_PartialAppManifest)" ItemName="_PostCompilePartialAppManifest" File="$(_CoreMLModel_PartialAppManifestCache)" Overwrite="true" IncludeMetadata="true" />
		<WriteItemsToFile Items="@(_CoreMLModel_BundleResources)" ItemName="_BundleResourceWithLogicalName" File="$(_CoreMLModel_BundleResourceCache)" Overwrite="true" IncludeMetadata="true" />
		<!-- Write out the list of assets we've processed, so that an inner build in a multi-rid build can skip processing them -->
		<WriteItemsToFile Items="@(CoreMLModel)" Condition="'$(_SaveProcessedItems)' == 'true'" ItemName="CoreMLModel" File="$(_ProcessedCoreMLModelsPath)" Overwrite="true" IncludeMetadata="false" />
		<ItemGroup>
			<FileWrites Include="$(_CoreMLModel_PartialAppManifestCache);$(_CoreMLModel_BundleResourceCache)" />
			<FileWrites Include="$(_ProcessedCoreMLModelsPath)" />
		</ItemGroup>
	</Target>

	<PropertyGroup>
		<_SmeltMetalDependsOn>
			_DetectSdkLocations;
			_ComputeTargetFrameworkMoniker;
			_ReadAppManifest;
		</_SmeltMetalDependsOn>
	</PropertyGroup>

	<Target Name="_SmeltMetal" Condition="'$(_CanOutputAppBundle)' == 'true' And '@(Metal)' != ''" DependsOnTargets="$(_SmeltMetalDependsOn)">
		<Metal
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' and '%(Metal.Identity)' != ''"
			IntermediateOutputPath="$(DeviceSpecificIntermediateOutputPath)"
			MinimumOSVersion="$(_MinimumOSVersion)"
			ProjectDir="$(MSBuildProjectDirectory)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
			ResourcePrefix="$(_ResourcePrefix)"
			SdkDevPath="$(_SdkDevPath)"
			SdkIsSimulator="$(_SdkIsSimulator)"
			SdkRoot="$(_SdkRoot)"
			SdkVersion="$(_SdkVersion)"
			SourceFile="@(Metal)">
			<Output TaskParameter="OutputFile" ItemName="_SmeltedMetal" />
		</Metal>
	</Target>

	<Target Name="_TemperMetal" Condition="'$(_CanOutputAppBundle)' == 'true' And '@(_SmeltedMetal)' != ''" DependsOnTargets="_GenerateBundleName"
		Inputs="@(_SmeltedMetal)" Outputs="$(_AppResourcesPath)default.metallib">
		<MetalLib
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			Items="@(_SmeltedMetal)"
			SdkDevPath="$(_SdkDevPath)"
			SdkRoot="$(_SdkRoot)"
			OutputLibrary="$(_AppResourcesPath)default.metallib">
		</MetalLib>
	</Target>

	<Target Name="_DetectAppManifest" DependsOnTargets="_GenerateBundleName;_ComputeTargetFrameworkMoniker">
		<!--
			This targets runs for Library projects as well, so that Library
			projects can specify an Info.plist with MinimumOSVersion to pass
			to actool, ibtool, and other Xcode tools.

			Ref: https://bugzilla.xamarin.com/show_bug.cgi?id=34736
		-->
		<FindItemWithLogicalName Condition="'$(AppManifestDetectionEnabled)' != 'false' And '$(AppBundleManifest)' == ''"
			SessionId="$(BuildSessionId)"
			ProjectDir="$(MSBuildProjectDirectory)"
			ResourcePrefix="$(_ResourcePrefix)"
			LogicalName="Info.plist"
			Items="@(None)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
			>
			<Output TaskParameter="Item" PropertyName="AppBundleManifest" />
		</FindItemWithLogicalName>
		<FindItemWithLogicalName Condition="'$(AppManifestDetectionEnabled)' != 'false' And '$(AppBundleManifest)' == '' And '$(_CanOutputAppBundle)' == 'true'"
			SessionId="$(BuildSessionId)"
			ProjectDir="$(MSBuildProjectDirectory)"
			ResourcePrefix="$(_ResourcePrefix)"
			LogicalName="Info.plist"
			Items="@(BundleResource)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
			>
			<Output TaskParameter="Item" PropertyName="AppBundleManifest" />
		</FindItemWithLogicalName>
		<FindItemWithLogicalName Condition="'$(AppManifestDetectionEnabled)' != 'false' And '$(AppBundleManifest)' == '' And '$(_CanOutputAppBundle)' == 'true'"
			SessionId="$(BuildSessionId)"
			ProjectDir="$(MSBuildProjectDirectory)"
			ResourcePrefix="$(_ResourcePrefix)"
			LogicalName="Info.plist"
			Items="@(Content)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
			>
			<Output TaskParameter="Item" PropertyName="AppBundleManifest" />
		</FindItemWithLogicalName>
		<Error Condition="'$(AppBundleManifest)' == '' And '$(_CanOutputAppBundle)' == 'true' And '$(UsingAppleNETSdk)' != 'true'" Text="Info.plist not found."/>
		<PropertyGroup>
			<_AppBundleManifestPath>$(_AppBundlePath)$(_AppBundleManifestRelativePath)Info.plist</_AppBundleManifestPath>
			<!-- We should only write out a compiled app manifest if we're creating an app bundle -->
			<_CreateAppManifest>$(_CanOutputAppBundle)</_CreateAppManifest>
			<_TemporaryAppManifest>$(DeviceSpecificIntermediateOutputPath)AppManifest.plist</_TemporaryAppManifest>
		</PropertyGroup>
	</Target>


	<!-- Optimize png images -->

	<PropertyGroup>
		<OptimizePngImagesDependsOn>
			_CollectPngImages;
			_CoreOptimizePngImages;
			_AfterCoreOptimizePngImages
		</OptimizePngImagesDependsOn>
	</PropertyGroup>

	<Target Name="_OptimizePngImages" DependsOnTargets="$(OptimizePngImagesDependsOn)" />

	<Target Name="_CollectPngImages" DependsOnTargets="_CollectBundleResources">
		<CreateItem Include="@(_BundleResourceWithLogicalName)" Condition="'%(_BundleResourceWithLogicalName.Extension)' == '.png' And '%(_BundleResourceWithLogicalName.Optimize)' == 'true'">
			<Output TaskParameter="Include" ItemName="_PngImage" />
		</CreateItem>
	</Target>

	<Target Name="_CoreOptimizePngImages"
		DependsOnTargets="_CollectPngImages;_DetectSdkLocations"
		Inputs="@(_PngImage)"
		Outputs="@(_PngImage -> '$(DeviceSpecificIntermediateOutputPath)optimized\%(LogicalName)')">

		<OptimizeImage
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			ToolExe="$(PngCrushExe)"
			ToolPath="$(PngCrushPath)"
			SdkDevPath="$(_SdkDevPath)"
			InputImages="@(_PngImage)"
			OutputImages="@(_PngImage -> '$(DeviceSpecificIntermediateOutputPath)optimized\%(LogicalName)')">
			<Output TaskParameter="OutputImages" ItemName="FileWrites" />
		</OptimizeImage>
	</Target>

	<Target Name="_AfterCoreOptimizePngImages" Condition="'@(_PngImage)' != ''">
		<ItemGroup>
			<_BundleResourceWithLogicalName Remove="@(_PngImage)" />
		</ItemGroup>

		<CreateItem Include="$(DeviceSpecificIntermediateOutputPath)optimized\%(_PngImage.LogicalName)" AdditionalMetadata="LogicalName=%(_PngImage.LogicalName);Optimize='false';ResourceTags=%(_PngImage.ResourceTags)">
			<Output TaskParameter="Include" ItemName="_BundleResourceWithLogicalName" />
		</CreateItem>
	</Target>

	<!-- Optimize property lists -->

	<PropertyGroup>
		<OptimizePropertyListsDependsOn>
			_CollectPropertyLists;
			_CoreOptimizePropertyLists;
			_AfterCoreOptimizePropertyLists
		</OptimizePropertyListsDependsOn>
	</PropertyGroup>

	<Target Name="_OptimizePropertyLists" DependsOnTargets="$(OptimizePropertyListsDependsOn)" />

	<Target Name="_CollectPropertyLists" DependsOnTargets="_CollectBundleResources">
		<CreateItem Include="@(_BundleResourceWithLogicalName)" Condition="'%(_BundleResourceWithLogicalName.Extension)' == '.plist' And '%(_BundleResourceWithLogicalName.Optimize)' == 'true'">
			<Output TaskParameter="Include" ItemName="_PropertyList" />
		</CreateItem>
		<ItemGroup>
			<FileWrites Include="$(DeviceSpecificIntermediateOutputPath)optimized\%(_PropertyList.LogicalName)" />
		</ItemGroup>
	</Target>

	<Target Name="_CoreOptimizePropertyLists"
		DependsOnTargets="_CollectPropertyLists;_DetectSdkLocations"
		Inputs="@(_PropertyList)"
		Outputs="$(DeviceSpecificIntermediateOutputPath)optimized\%(_PropertyList.LogicalName)"
		>

		<OptimizePropertyList
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			ToolExe="$(PlUtilExe)"
			ToolPath="$(PlUtilPath)"
			Input="%(_PropertyList.Identity)"
			Output="$(DeviceSpecificIntermediateOutputPath)optimized\%(_PropertyList.LogicalName)">
		</OptimizePropertyList>
	</Target>

	<Target Name="_AfterCoreOptimizePropertyLists" Condition="'@(_PropertyList)' != ''">
		<ItemGroup>
			<_BundleResourceWithLogicalName Remove="@(_PropertyList)" />
		</ItemGroup>

		<CreateItem Include="$(DeviceSpecificIntermediateOutputPath)optimized\%(_PropertyList.LogicalName)" AdditionalMetadata="LogicalName=%(_PropertyList.LogicalName);Optimize='false'">
			<Output TaskParameter="Include" ItemName="_BundleResourceWithLogicalName" />
		</CreateItem>
	</Target>

	<!-- Optimize localization files (*.strings) -->

	<PropertyGroup>
		<OptimizeLocalizationFilesDependsOn>
			_CollectLocalizationFiles;
			_CoreOptimizeLocalizationFiles;
			_AfterCoreOptimizeLocalizationFiles
		</OptimizeLocalizationFilesDependsOn>
	</PropertyGroup>

	<Target Name="_OptimizeLocalizationFiles" DependsOnTargets="$(OptimizeLocalizationFilesDependsOn)" />

	<Target Name="_CollectLocalizationFiles" DependsOnTargets="_CollectBundleResources">
		<CreateItem Include="@(_BundleResourceWithLogicalName)" Condition="'%(_BundleResourceWithLogicalName.Extension)' == '.strings' And '%(_BundleResourceWithLogicalName.Optimize)' == 'true'">
			<Output TaskParameter="Include" ItemName="_LocalizationFile" />
		</CreateItem>
		<ItemGroup>
			<FileWrites Include="$(DeviceSpecificIntermediateOutputPath)optimized\%(_LocalizationFile.LogicalName)" />
		</ItemGroup>
	</Target>

	<Target Name="_CoreOptimizeLocalizationFiles"
		DependsOnTargets="_CollectLocalizationFiles;_DetectSdkLocations"
		Inputs="@(_LocalizationFile)"
		Outputs="$(DeviceSpecificIntermediateOutputPath)optimized\%(_LocalizationFile.LogicalName)"
		>

		<OptimizePropertyList
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			ToolExe="$(PlUtilExe)"
			ToolPath="$(PlUtilPath)"
			Input="%(_LocalizationFile.Identity)"
			Output="$(DeviceSpecificIntermediateOutputPath)optimized\%(_LocalizationFile.LogicalName)">
		</OptimizePropertyList>
	</Target>

	<Target Name="_AfterCoreOptimizeLocalizationFiles" Condition="'@(_LocalizationFile)' != ''">
		<ItemGroup>
			<_BundleResourceWithLogicalName Remove="@(_LocalizationFile)" />
		</ItemGroup>

		<CreateItem Include="$(DeviceSpecificIntermediateOutputPath)optimized\%(_LocalizationFile.LogicalName)" AdditionalMetadata="LogicalName=%(_LocalizationFile.LogicalName);Optimize='false'">
			<Output TaskParameter="Include" ItemName="_BundleResourceWithLogicalName" />
		</CreateItem>
	</Target>

	<PropertyGroup Condition="'$(IsBindingProject)' == 'true'">
		<!-- Add our own pre and post build steps -->
		<!-- Override the CoreCompile Target to use bgen -->
		<CompileDependsOn>
			_GenerateBindings;
			_PrepareNativeReferences;
			_CollectGeneratedSources;
			$(CompileDependsOn)
			_CreateBindingResourcePackage;
		</CompileDependsOn>
	</PropertyGroup>

	<PropertyGroup>
		<_GenerateBindingsDependsOn>
			_ComputeTargetFrameworkMoniker;
			$(_GenerateBindingsDependsOn);
		</_GenerateBindingsDependsOn>
	</PropertyGroup>

	<Target Name="_GenerateBindings"
		Inputs="$(MSBuildAllProjects);@(ObjcBindingApiDefinition);@(ObjcBindingCoreSource);@(ReferencePath);@(ObjcBindingNativeLibrary)"
		Outputs="$(_GeneratedSourcesFileList)"
		DependsOnTargets="$(_GenerateBindingsDependsOn)"
		Condition="'$(IsBindingProject)' == 'true' And '$(DesignTimeBuild)' != 'true'">

		<ItemGroup>
			<BTouchReferencePath Include="@(ReferenceCopyLocalPaths)" Condition="'%(Extension)' == '.dll'" />
		</ItemGroup>

		<PropertyGroup>
			<BTouchEmitDebugInformation>false</BTouchEmitDebugInformation>
			<BTouchEmitDebugInformation Condition="'$(Debug)' != ''">true</BTouchEmitDebugInformation>
		</PropertyGroup>

		<MakeDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Directories="$(GeneratedSourcesDir)" />

		<FindCscCompiler
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '$(UsingAppleNETSdk)' == 'true' And !Exists('$(_DotNetCscCompiler)')"
			CscCompiler="$(_DotNetCscCompiler)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
		>
			<Output TaskParameter="CscCompiler" PropertyName="_DotNetCscCompiler" />
		</FindCscCompiler>

		<BTouch
			Condition="'$(IsMacEnabled)' == 'true'"
			SessionId="$(BuildSessionId)"
			OutputPath="$(OutputPath)"
			ObjectiveCLibraries="@(ObjcBindingNativeLibrary)"
			AdditionalLibPaths="$(AdditionalLibPaths)"
			AllowUnsafeBlocks="$(AllowUnsafeBlocks)"
			ApiDefinitions="@(ObjcBindingApiDefinition)"
			AttributeAssembly="$(_GeneratorAttributeAssembly)"
			BaseLibDll="$(BaseLibDllPath)"
			CoreSources="@(ObjcBindingCoreSource)"
			DefineConstants="$(DefineConstants)"
			DotNetCscCompiler="$(_DotNetCscCompiler)"
			EmitDebugInformation="$(BTouchEmitDebugInformation)"
			ExtraArgs="$(BTouchExtraArgs)"
			GeneratedSourcesDir="$(GeneratedSourcesDir)"
			GeneratedSourcesFileList="$(_GeneratedSourcesFileList)"
			Namespace="$(Namespace)"
			OutputAssembly="$(OutputAssembly)"
			ProcessEnums="$(ProcessEnums)"
			ProjectDir="$(MSBuildProjectDirectory)"
			References="@(ReferencePath);@(BTouchReferencePath)"
			ResponseFilePath="$(DeviceSpecificIntermediateOutputPath)response-file.rsp"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
			BTouchToolPath="$(BTouchToolPath)"
			BTouchToolExe="$(BTouchToolExe)"
			StandardOutputImportance="High"
			>
		</BTouch>
	</Target>

	<Target Name="_GetCompileToNativeInputs"
		DependsOnTargets="ResolveReferences">
		<ItemGroup>
			<!-- Skip the reference assemblies. Execution may fail at runtime if they're copied to the .app (instead of the implementation assembly), or AOT will fail in both 'mtouch' and 'mmp'. Similar to: https://github.com/xamarin/xamarin-macios/issues/3199 -->
			<!-- Remove exact references, such as if a package had a framework reference to 'System' that we already have -->
			<!-- This is exactly what "Microsoft.NuGet.Build.Tasks"'s 'ResolveNuGetPackageAssets' target is doing -->
			<!-- Effectively 'ResolveNuGetPackageAssets' computes the NuGet packages using their json asset file, adds the full assemblies to 'ReferenceCopyLocalPaths' and outputs the resolved references via '_ReferencesFromNuGetPackages' -->
			<ReferencePath Remove="@(_ReferencesFromNuGetPackages)" />
			<!-- It seems newer version of the .NET SDK uses the 'ResolvedCompileFileDefinitions' property instead of '_ReferencesFromNuGetPackages' -->
			<ReferencePath Remove="@(ResolvedCompileFileDefinitions)" />
			<_BundlerReferencePath Include="@(ReferenceCopyLocalPaths)" Condition="'%(Extension)' == '.dll'" />
			<_CompileToNativeInput Include="$(TargetDir)$(TargetFileName);@(_BundlerReferencePath)" />
			<_CompileToNativeInput Condition="'@(_ResolvedAppExtensionReferences)' != ''" Include="%(_ResolvedAppExtensionReferences.Identity)\..\bundler.stamp" />
		</ItemGroup>
	</Target>

	<PropertyGroup>
		<_DetectSigningIdentityDependsOn>
			$(_DetectSigningIdentityDependsOn);
			_DetectSdkLocations;
			_ComputeTargetFrameworkMoniker;
			_GenerateBundleName;
			_ReadAppManifest;
		</_DetectSigningIdentityDependsOn>
	</PropertyGroup>

	<Target Name="_DetectSigningIdentity" Condition="'$(_CanOutputAppBundle)' == 'true'" DependsOnTargets="$(_DetectSigningIdentityDependsOn)">
		<DetectSigningIdentity
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			AppBundleName="$(_AppBundleName)"
			BundleIdentifier="$(_BundleIdentifier)"
			Keychain="$(CodesignKeychain)"
			RequireCodeSigning="$(_RequireCodeSigning)"
			RequireProvisioningProfile="$(_RequireProvisioningProfile)"
			SdkIsSimulator="$(_SdkIsSimulator)"
			SdkPlatform="$(_SdkPlatform)"
			ProvisioningProfile="$(CodesignProvision)"
			SigningKey="$(_SpecifiedCodesignKey)"
			DetectedCodeSigningKey="$(_CodeSigningKey)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
			>

			<Output TaskParameter="DetectedAppId" PropertyName="_AppIdentifier" />
			<Output TaskParameter="DetectedCodeSigningKey" PropertyName="_CodeSigningKey" />
			<Output TaskParameter="DetectedCodesignAllocate" PropertyName="_CodesignAllocate" />
			<Output TaskParameter="DetectedDistributionType" PropertyName="_DistributionType" />
			<Output TaskParameter="DetectedProvisioningProfile" PropertyName="_ProvisioningProfile" />
		</DetectSigningIdentity>

		<PropertyGroup>
			<_EmbeddedProvisionProfilePath Condition="'$(_EmbeddedProvisionProfilePath)' == '' And ('$(_PlatformName)' == 'macOS' Or '$(_PlatformName)' == 'MacCatalyst')">$(_AppBundlePath)Contents\embedded.provisionprofile</_EmbeddedProvisionProfilePath>
			<_EmbeddedProvisionProfilePath Condition="'$(_EmbeddedProvisionProfilePath)' == '' And ('$(_PlatformName)' == 'iOS' Or '$(_PlatformName)' == 'tvOS' Or '$(_PlatformName)' == 'watchOS')">$(_AppBundlePath)embedded.mobileprovision</_EmbeddedProvisionProfilePath>
		</PropertyGroup>
	</Target>

	<Target Name="_DetectSdkLocations" DependsOnTargets="_ComputeTargetArchitectures;_ComputeTargetFrameworkMoniker">
		<DetectSdkLocations
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			IsDotNetSimulatorBuild="$(_IsDotNetSimulatorBuild)"
			SdkVersion="$(_SdkVersion)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
			TargetArchitectures="$(TargetArchitectures)"
			XamarinSdkRoot="$(_XamarinSdkRootOnMac)"
			>

			<Output TaskParameter="SdkVersion" PropertyName="_SdkVersion" />
			<Output TaskParameter="SdkRoot" PropertyName="_SdkRoot" />
			<Output TaskParameter="SdkBinPath" PropertyName="_SdkBinPath" />
			<Output TaskParameter="SdkDevPath" PropertyName="_SdkDevPath" />
			<Output TaskParameter="SdkUsrPath" PropertyName="_SdkUsrPath" />
			<Output TaskParameter="SdkPlatform" PropertyName="_SdkPlatform" />
			<Output TaskParameter="SdkIsSimulator" PropertyName="_SdkIsSimulator" />
			<Output TaskParameter="XamarinSdkRoot" PropertyName="_XamarinSdkRoot" />
		</DetectSdkLocations>
	</Target>

	<Target Name="_EmbedProvisionProfile" Condition="'$(_ProvisioningProfile)' != ''" DependsOnTargets="_GenerateBundleName;_DetectSigningIdentity"
		Outputs="$(_EmbeddedProvisionProfilePath)">
		<EmbedProvisionProfile
			Condition="'$(IsMacEnabled)' == 'true'"
			SessionId="$(BuildSessionId)"
			AppBundleDir="$(AppBundleDir)"
			ProvisioningProfile="$(_ProvisioningProfile)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
			EmbeddedProvisionProfilePath="$(_EmbeddedProvisionProfilePath)"
			>
		</EmbedProvisionProfile>
	</Target>

	<Target Name="_PackLibraryResources" Condition="'$(_CanOutputAppBundle)' == 'false'" DependsOnTargets="_CollectBundleResources">
		<PackLibraryResources
			Condition="'$(IsMacEnabled)' == 'true'"
			SessionId="$(BuildSessionId)"
			Prefix="$(_EmbeddedResourcePrefix)"
			BundleResourcesWithLogicalNames="@(_BundleResourceWithLogicalName)">
			<Output TaskParameter="EmbeddedResources" ItemName="EmbeddedResource" />
		</PackLibraryResources>
	</Target>

	<Target Name="_UnpackLibraryResources" Condition="'$(_CanOutputAppBundle)' == 'true'" DependsOnTargets="ResolveReferences;_CollectBundleResources">
		<UnpackLibraryResources
			Condition="'$(IsMacEnabled)' == 'true'"
			SessionId="$(BuildSessionId)"
			Prefix="$(_EmbeddedResourcePrefix)"
			NoOverwrite="@(_BundleResourceWithLogicalName)"
			IntermediateOutputPath="$(DeviceSpecificIntermediateOutputPath)"
			TargetFrameworkDirectory="$(TargetFrameworkDirectory)"
			ReferencedLibraries="@(ReferencePath);@(ReferenceDependencyPaths)">
			<Output TaskParameter="BundleResourcesWithLogicalNames" ItemName="_BundleResourceWithLogicalName" />
		</UnpackLibraryResources>
	</Target>

	<Target Name="_ParseBundlerArguments">
		<ParseBundlerArguments
			ExtraArgs="$(_BundlerArguments)"
			NoSymbolStrip="$(_NoSymbolStrip)"
			NoDSymUtil="$(_NoDSymUtil)"
			PackageDebugSymbols="$(PackageDebugSymbols)"
			Verbosity="$(_BundlerVerbosity)"
			>
			<Output TaskParameter="CustomBundleName" PropertyName="_CustomBundleName" />
			<Output TaskParameter="CustomLinkFlags" ItemName="_CustomLinkFlags" />
			<Output TaskParameter="DlSym" ItemName="_BundlerDlsym" />
			<Output TaskParameter="EnvironmentVariables" ItemName="_BundlerEnvironmentVariables" />
			<Output TaskParameter="MarshalManagedExceptionMode" PropertyName="_MarshalManagedExceptionMode" />
			<Output TaskParameter="MarshalObjectiveCExceptionMode" PropertyName="_MarshalObjectiveCExceptionMode" />
			<Output TaskParameter="NoSymbolStrip" PropertyName="_NoSymbolStrip"/>
			<Output TaskParameter="NoDSymUtil" PropertyName="_NoDSymUtil"/>
			<Output TaskParameter="Optimize" PropertyName="_BundlerOptimize"/>
			<Output TaskParameter="PackageDebugSymbols" PropertyName="PackageDebugSymbols" />
			<Output TaskParameter="Registrar" PropertyName="_BundlerRegistrar" />
			<Output TaskParameter="Verbosity" PropertyName="_BundlerVerbosity" />
			<Output TaskParameter="XmlDefinitions" ItemName="_BundlerXmlDefinitions" />
			<Output TaskParameter="NoStrip" PropertyName="EnableAssemblyILStripping" />
		</ParseBundlerArguments>

		<PropertyGroup>
			<_CustomBundleName Condition="'$(_CustomBundleName)' == ''">MonoBundle</_CustomBundleName>
		</PropertyGroup>
	</Target>

	<!-- Code signing -->

	<PropertyGroup>
		<_CodesignAppBundleDependsOn>
			$(_CodesignAppBundleDependsOn);
			_CleanAppBundleRootDirectory;
			_EmbedProvisionProfile;
			_CodesignNativeLibraries;
			_CollectFrameworks;
			_CodesignFrameworks;
			_ReadAppExtensionCodesignProperties;
			_CodesignAppExtensions;
			_PrepareCodesignAppExtension;
			_CalculateCodesignAppBundleInputs;
		</_CodesignAppBundleDependsOn>

		<CoreCodesignDependsOn>
			$(CoreCodesignDependsOn);
			$(_CodesignAppBundleDependsOn);
			_CodesignAppBundle;
			_CodesignVerify;
		</CoreCodesignDependsOn>

		<CodesignDependsOn>
			$(CodesignDependsOn);
			_CreateAppBundle;
			BeforeCodeSign;
			CoreCodeSign;
			AfterCodeSign;
		</CodesignDependsOn>
	</PropertyGroup>

	<Target Name="BeforeCodesign" />
	<Target Name="CoreCodesign" DependsOnTargets="$(CoreCodesignDependsOn)" />
	<Target Name="AfterCodesign" />

	<Target Name="Codesign" Condition="'$(_CanOutputAppBundle)' == 'true'" DependsOnTargets="$(CodesignDependsOn)" />

	<PropertyGroup>
		<_CodesignNativeLibrariesDependsOn>
			$(_CodesignNativeLibrariesDependsOn);
			_DetectSigningIdentity;
			_CompileToNative;
			_PlaceAppExtensions;
		</_CodesignNativeLibrariesDependsOn>
	</PropertyGroup>

	<!-- Note:
		Always codesign *.dylibs even for Simulator builds for iOS/tvOS/watchOS. We use $(_CanOutputAppBundle) because dylibs can exist in app extensions as well.
		For macOS we sign if _RequireCodeSigning is true
	-->
	<Target Name="_CodesignNativeLibraries" Condition="'$(_CanOutputAppBundle)' == 'true' And ('$(_RequireCodeSigning)' == 'true' Or '$(_PlatformName)' != 'macOS')" DependsOnTargets="$(_CodesignNativeLibrariesDependsOn)">

		<PropertyGroup>
			<_CodesignDisableTimestamp>False</_CodesignDisableTimestamp>
			<_CodesignDisableTimestamp Condition="'$(_SdkIsSimulator)' == 'true' Or '$(_BundlerDebug)' == 'true'">True</_CodesignDisableTimestamp>
			<_LibraryCodeSigningKey>$(_CodeSigningKey)</_LibraryCodeSigningKey>
			<_LibraryCodeSigningKey Condition="'$(_LibraryCodeSigningKey)' == ''">-</_LibraryCodeSigningKey>
		</PropertyGroup>

		<ItemGroup Condition="'$(_PlatformName)' == 'macOS' Or '$(_PlatformName)' == 'MacCatalyst'">
			<_CodesignNativeLibrary Include="$(_AppContentsPath)\**\*.dylib" />
			<_CodesignNativeLibrary Include="$(_AppResourcesPath)\**\*.metallib" />
		</ItemGroup>
		<ItemGroup Condition="'$(_PlatformName)' == 'iOS' Or '$(_PlatformName)' == 'tvOS' Or '$(_PlatformName)' == 'watchOS'">
			<_CodesignNativeLibrary
				Include="$(_AppBundlePath)\**\*.dylib;$(_AppBundlePath)\**\*.metallib"
				Exclude="$(_AppBundlePath)\Watch\**;$(_AppExtensionRoot)\PlugIns\**"
				/>
		</ItemGroup>

		<ItemGroup>
			<_CodesignItems Include="@(_CodesignNativeLibrary)">
				<CodesignAllocate>$(_CodesignAllocate)</CodesignAllocate>
				<CodesignDeep>$(IsAppExtension)</CodesignDeep>
				<CodesignDisableTimestamp>$(_CodesignDisableTimestamp)</CodesignDisableTimestamp>
				<!-- CodesignEntitlements -->
				<CodesignExtraArgs>$(CodesignExtraArgs)</CodesignExtraArgs>
				<CodesignKeychain>$(CodesignKeychain)</CodesignKeychain>
				<!-- CodesignResourceRules -->
				<CodesignSigningKey>$(_LibraryCodeSigningKey)</CodesignSigningKey>
				<CodesignStampPath>$(DeviceSpecificIntermediateOutputPath)codesign\</CodesignStampPath>
				<!-- CodesignUseHardenedRuntime-->
				<CodesignUseSecureTimestamp>$(UseHardenedRuntime)</CodesignUseSecureTimestamp>
			</_CodesignItems>
		</ItemGroup>
	</Target>

	<Target Name="_CodesignVerify" Condition="'$(_RequireCodeSigning)' == 'true' And ('$(IsAppExtension)' == 'false' Or '@(_ResolvedAppExtensionReferences)' != '')" DependsOnTargets="_CodesignAppBundle">
		<CodesignVerify
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '@(_ResolvedAppExtensionReferences)' != ''"
			ToolExe="$(CodesignExe)"
			ToolPath="$(CodesignPath)"
			CodesignAllocate="$(_CodesignAllocate)"
			Resource="$(_AppExtensionRoot)PlugIns\%(_ResolvedAppExtensionReferences.Filename)%(_ResolvedAppExtensionReferences.Extension)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
		>
		</CodesignVerify>

		<CodesignVerify
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			ToolExe="$(CodesignExe)"
			ToolPath="$(CodesignPath)"
			CodesignAllocate="$(_CodesignAllocate)"
			Resource="$(AppBundleDir)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
		>
		</CodesignVerify>
	</Target>

	<PropertyGroup>
		<_CollectFrameworksDependsOn>
			$(_CollectFrameworksDependsOn);
			_DetectSigningIdentity;
			_CompileToNative;
		</_CollectFrameworksDependsOn>
	</PropertyGroup>

	<Target Name="_CollectFrameworks" Condition="'$(_CanOutputAppBundle)' == 'true'" DependsOnTargets="$(_CollectFrameworksDependsOn)">
		<PropertyGroup>
			<_FrameworksDirectory Condition="'$(_FrameworksDirectory)' == '' And ('$(_PlatformName)' == 'iOS' Or '$(_PlatformName)' == 'tvOS' Or '$(_PlatformName)' == 'watchOS')">$(_AppBundlePath)/Frameworks</_FrameworksDirectory>
			<_FrameworksDirectory Condition="'$(_FrameworksDirectory)' == '' And ('$(_PlatformName)' == 'macOS' Or '$(_PlatformName)' == 'MacCatalyst')">$(_AppBundlePath)/Contents/Frameworks</_FrameworksDirectory>
		</PropertyGroup>
		<CollectFrameworks
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			FrameworksDirectory="$(_FrameworksDirectory)"
			>
			<Output TaskParameter="Frameworks" ItemName="_Frameworks"/>
		</CollectFrameworks>
		<PropertyGroup>
			<_MustCodesignFrameworks Condition="'$(_PlatformName)' == 'macOS' And '$(_RequireCodeSigning)' == 'true' And '@(_Frameworks)' != ''">true</_MustCodesignFrameworks>
			<_MustCodesignFrameworks Condition="'$(_PlatformName)' != 'macOS' And '$(_CanOutputAppBundle)' == 'true' And '@(_Frameworks)' != ''">true</_MustCodesignFrameworks>
		</PropertyGroup>
	</Target>

	<Target Name="_CodesignFrameworks" Condition="'$(_MustCodesignFrameworks)' == 'true'" DependsOnTargets="_DetectSigningIdentity;_CollectFrameworks">

		<PropertyGroup>
			<_CodesignDisableTimestamp>False</_CodesignDisableTimestamp>
			<_CodesignDisableTimestamp Condition="'$(_SdkIsSimulator)' == 'true' Or '$(_BundlerDebug)' == 'true'">True</_CodesignDisableTimestamp>
			<_FrameworkCodeSigningKey>$(_CodeSigningKey)</_FrameworkCodeSigningKey>
			<_FrameworkCodeSigningKey Condition="'$(_FrameworkCodeSigningKey)' == ''">-</_FrameworkCodeSigningKey>
		</PropertyGroup>

		<ItemGroup>
			<_CodesignItems Include="@(_Frameworks)">
				<CodesignAllocate>$(_CodesignAllocate)</CodesignAllocate>
				<!-- CodesignDeep -->
				<CodesignDisableTimestamp>$(_CodesignDisableTimestamp)</CodesignDisableTimestamp>
				<!-- CodesignEntitlements -->
				<CodesignExtraArgs>$(CodesignExtraArgs)</CodesignExtraArgs>
				<CodesignKeychain>$(CodesignKeychain)</CodesignKeychain>
				<!-- CodesignResourceRules -->
				<CodesignSigningKey>$(_FrameworkCodeSigningKey)</CodesignSigningKey>
				<!-- CodesignUseHardenedRuntime -->
				<CodesignUseSecureTimestamp>$(UseHardenedRuntime)</CodesignUseSecureTimestamp>
			</_CodesignItems>
		</ItemGroup>
	</Target>

	<Target Name="_ReadAppExtensionCodesignProperties">
		<ReadItemsFromFile File="%(_ResolvedAppExtensionReferences.Identity)\..\codesign.items" Condition="Exists('%(_ResolvedAppExtensionReferences.Identity)\..\codesign.items')">
			<Output TaskParameter="Items" ItemName="_AppExtensionCodesignProperties" />
		</ReadItemsFromFile>
	</Target>

	<Target Name="_CodesignAppExtensions"
		Condition="'$(_CanOutputAppBundle)' == 'true' And '@(_AppExtensionCodesignProperties)' != ''"
		DependsOnTargets="_DetectSigningIdentity;_ReadAppExtensionCodesignProperties"
		>

		<PropertyGroup>
			<_CodesignAppExtensionsLibraryPath>$(_AppPlugInsPath)%(_AppExtensionCodesignProperties.Identity)\</_CodesignAppExtensionsLibraryPath>
		</PropertyGroup>

		<ItemGroup>
			<_CodesignAppExtensionsLibrary
				Include="$(_CodesignAppExtensionsLibraryPath)**\*.dylib;$(_CodesignAppExtensionsLibraryPath)**\*.metallib"
				Exclude="$(_CodesignAppExtensionsLibraryPath)Watch\**;$(_CodesignAppExtensionsLibraryPath)$(_AppPlugInsRelativePath)\**"
				>
			</_CodesignAppExtensionsLibrary>
		</ItemGroup>

		<ItemGroup>
			<_CodesignItems Include="@(_CodesignAppExtensionsLibrary)" Condition="'%(_AppExtensionCodesignProperties.LibrarySigningKey)' != ''">
				<CodesignAllocate>%(_AppExtensionCodesignProperties.CodesignAllocate)</CodesignAllocate>
				<!-- CodesignDeep -->
				<CodesignDisableTimestamp>%(_AppExtensionCodesignProperties.DisableTimestamp)</CodesignDisableTimestamp>
				<!-- CodesignEntitlements -->
				<CodesignExtraArgs>%(_AppExtensionCodesignProperties.ExtraArgs)</CodesignExtraArgs>
				<CodesignKeychain>%(_AppExtensionCodesignProperties.Keychain)</CodesignKeychain>
				<!-- CodesignResourceRules -->
				<CodesignSigningKey>%(_AppExtensionCodesignProperties.LibrarySigningKey)</CodesignSigningKey>
				<CodesignStampPath>$(DeviceSpecificIntermediateOutputPath)codesign\PlugIns\%(_AppExtensionCodesignProperties.Identity)</CodesignStampPath>
				<!-- CodesignUseHardenedRuntime -->
				<!-- CodesignUseSecureTimestamp -->
			</_CodesignItems>
		</ItemGroup>

		<ItemGroup>
			<_CodesignItems Include="$(_AppPlugInsPath)%(_AppExtensionCodesignProperties.Identity)" Condition="'%(_AppExtensionCodesignProperties.SigningKey)' != ''">
				<CodesignAllocate>%(_AppExtensionCodesignProperties.CodesignAllocate)</CodesignAllocate>
				<!-- CodesignDeep -->
				<CodesignDisableTimestamp>%(_AppExtensionCodesignProperties.DisableTimestamp)</CodesignDisableTimestamp>
				<CodesignEntitlements>%(_AppExtensionCodesignProperties.Entitlements)</CodesignEntitlements>
				<CodesignExtraArgs>%(_AppExtensionCodesignProperties.ExtraArgs)</CodesignExtraArgs>
				<CodesignKeychain>%(_AppExtensionCodesignProperties.Keychain)</CodesignKeychain>
				<CodesignResourceRules>%(_AppExtensionCodesignProperties.ResourceRules)</CodesignResourceRules>
				<CodesignSigningKey>%(_AppExtensionCodesignProperties.SigningKey)</CodesignSigningKey>
				<!-- CodesignStampPath -->
				<!-- CodesignUseHardenedRuntime -->
				<!-- CodesignUseSecureTimestamp -->
			</_CodesignItems>
		</ItemGroup>
	</Target>

	<Target Name="_PrepareCodesignAppExtension" Condition="'$(_CanOutputAppBundle)' == 'true' And '$(IsAppExtension)' == 'true' And '@(_ResolvedAppBundleExtensions)' == ''">
		<!-- For App Extensions, we delay running codesign until it has been copied into the main app bundle... -->
		<PropertyGroup>
			<_CompiledEntitlementsFullPath></_CompiledEntitlementsFullPath>
			<_ResourceRulesFullPath></_ResourceRulesFullPath>
		</PropertyGroup>

		<GetFullPath SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" RelativePath="$(AppBundleDir)">
			<Output TaskParameter="FullPath" PropertyName="_AppBundleFullPath" />
		</GetFullPath>

		<GetFullPath SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true' And '$(_CompiledCodesignEntitlements)' != ''" RelativePath="$(_CompiledCodesignEntitlements)">
			<Output TaskParameter="FullPath" PropertyName="_CompiledEntitlementsFullPath" />
		</GetFullPath>

		<GetFullPath SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true' And '$(_PreparedResourceRules)' != ''" RelativePath="$(_PreparedResourceRules)">
			<Output TaskParameter="FullPath" PropertyName="_ResourceRulesFullPath" />
		</GetFullPath>

		<GetFiles SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Path="$(_AppBundleFullPath)" Pattern="*.*" Option="AllDirectories">
			<Output TaskParameter="Files" ItemName="_AppExtensionBundleFiles" />
		</GetFiles>

		<PropertyGroup>
			<!-- [System.IO.Path]::GetFileName() is safe to use -->
			<_AppBundleFileName>$([System.IO.Path]::GetFileName('$(AppBundleDir)'))</_AppBundleFileName>
			<_NativeExecutableFileName>$([System.IO.Path]::GetFileName('$(_NativeExecutable)'))</_NativeExecutableFileName>

			<_CodesignDisableTimestamp>False</_CodesignDisableTimestamp>
			<_CodesignDisableTimestamp Condition="'$(_SdkIsSimulator)' == 'true' Or '$(_BundlerDebug)' == 'true'">True</_CodesignDisableTimestamp>

			<_CodesignAppExtensionInputs>@(_AppExtensionBundleFiles);$(_EntitlementsFullPath)</_CodesignAppExtensionInputs>

			<_LibrarySigningKey>$(_CodeSigningKey)</_LibrarySigningKey>
			<_LibrarySigningKey Condition="'$(_LibrarySigningKey)' == ''">-</_LibrarySigningKey>
		</PropertyGroup>

		<ItemGroup>
			<_AppExtensionCodesignPropertiesToWrite Include="$(_AppBundleFileName)">
				<CodesignAppExtensionInputs>$(_CodesignAppExtensionInputs)</CodesignAppExtensionInputs>
				<NativeExecutable>$(_NativeExecutableFileName)</NativeExecutable>
				<CodesignAllocate>$(_CodesignAllocate)</CodesignAllocate>
				<DisableTimestamp>$(_CodesignDisableTimestamp)</DisableTimestamp>
				<Entitlements>$(_CompiledEntitlementsFullPath)</Entitlements>
				<ResourceRules>$(_ResourceRulesFullPath)</ResourceRules>
				<Keychain>$(CodesignKeychain)</Keychain>
				<LibrarySigningKey>$(_LibrarySigningKey)</LibrarySigningKey>
				<SigningKey>$(_CodeSigningKey)</SigningKey>
				<ExtraArgs>$(CodesignExtraArgs)</ExtraArgs>
			</_AppExtensionCodesignPropertiesToWrite>
		</ItemGroup>

		<WriteItemsToFile
			Condition="'$(IsMacEnabled)' == 'true'"
			Items="@(_AppExtensionCodesignPropertiesToWrite)"
			ItemName="_AppExtensionCodesignProperties"
			File="$(DeviceSpecificOutputPath)codesign.items"
			IncludeMetadata="true"
			Overwrite="true"
		/>
	</Target>

	<Target Name="_CalculateCodesignAppBundleInputs">
		<ItemGroup>
			<_CodesignAppBundleInputs Include="$(_AppBundlePath)**\*.*" Exclude="$(_AppCodeSignaturePath)_CodeSignature\CodeResources" />
		</ItemGroup>

		<PropertyGroup>
			<_CodesignDisableTimestamp>False</_CodesignDisableTimestamp>
			<_CodesignDisableTimestamp Condition="'$(_SdkIsSimulator)' == 'true' Or '$(_BundlerDebug)' == 'true'">True</_CodesignDisableTimestamp>

			<_AppBundleCodesignEntitlements Condition="'$(_PlatformName)' == 'macOS'">$(IntermediateOutputPath)Entitlements.xcent</_AppBundleCodesignEntitlements>
			<_AppBundleCodesignEntitlements Condition="'$(_PlatformName)' != 'macOS'">$(_CompiledCodesignEntitlements)</_AppBundleCodesignEntitlements>

			<_CodesignAppBundleCondition Condition="'$(_PlatformName)' == 'macOS' And '$(_RequireCodeSigning)'">true</_CodesignAppBundleCondition>
			<_CodesignAppBundleCondition Condition="'$(_PlatformName)' != 'macOS' And ('$(_CanOutputAppBundle)' == 'true' And '$(_CodeSigningKey)' != '') And ('$(IsAppExtension)' == 'false' Or '@(_ResolvedAppExtensionReferences)' != '')">true</_CodesignAppBundleCondition>
		</PropertyGroup>

		<ItemGroup Condition="'$(_CodesignAppBundleCondition)' == 'true'">
			<_CodesignItems Include="$(AppBundleDir)">
				<CodesignAllocate>$(_CodesignAllocate)</CodesignAllocate>
				<CodesignAdditionalFilesToTouch>$(AppBundleDir).dSYM\Contents\Info.plist</CodesignAdditionalFilesToTouch>
				<CodesignDeep>$(IsAppExtension)</CodesignDeep>
				<CodesignDisableTimestamp>$(_CodesignDisableTimestamp)</CodesignDisableTimestamp>
				<CodesignEntitlements>$(_AppBundleCodesignEntitlements)</CodesignEntitlements>
				<CodesignExtraArgs>$(CodesignExtraArgs)</CodesignExtraArgs>
				<CodesignKeychain>$(CodesignKeychain)</CodesignKeychain>
				<CodesignResourceRules>$(_PreparedResourceRules)</CodesignResourceRules>
				<CodesignSigningKey>$(_CodeSigningKey)</CodesignSigningKey>
				<CodesignStampFile>$(_AppCodeSignaturePath)_CodeSignature\CodeResources</CodesignStampFile>
				<!-- CodesignStampPath -->
				<CodesignUseHardenedRuntime>$(UseHardenedRuntime)</CodesignUseHardenedRuntime>
				<CodesignUseSecureTimestamp>$(UseHardenedRuntime)</CodesignUseSecureTimestamp>
			</_CodesignItems>
		</ItemGroup>

		<!-- Compute some metadata for the items -->
		<ItemGroup>
			<!-- Compute the relative path of the item in the app bundle -->
			<_CodesignItems>
				<CodesignRelativeAppBundlePath>$([System.String]::new('%(Identity)').Substring($([MSBuild]::Add($([System.String]::new('%(Identity)').LastIndexOf('.app/')),5))))</CodesignRelativeAppBundlePath>
			</_CodesignItems>
			<!-- Set CodesignStampPath if it's not set already -->
			<_CodesignItems Condition="'%(_CodesignItems.CodesignStampPath)' == ''">
				<CodesignStampPath>$(DeviceSpecificIntermediateOutputPath)codesign\</CodesignStampPath>
				<IsInputDirectory Condition="Exists('%(_CodesignItems.Identity)') And !$([System.IO.File]::Exists('%(_CodesignItems.Identity)'))">true</IsInputDirectory>
			</_CodesignItems>
			<!-- Set CodesignStampFile if it's not set already -->
			<!-- Don't use a directory as a stamp file, instead use a file inside that directory -->
			<!-- This checks if the input is a directory, because we can't check if the stamp location might be (it might not exist yet) -->
			<!-- Unfortunately System.IO.Directory.Exists can't be called from MSBuild, so we combine two other methods:
				1. The built-in 'Exists' condition returns true if the input is either a file or a directory (and it exists)
				2. We can call System.IO.File.Exists, which only returns true if the input is a file (and it exists).
				3. So we can determine that the input is a directory, if the built-in 'Exists' return true, but System.IO.File.Exists return false
			-->
			<_CodesignItems Condition="'%(_CodesignItems.CodesignStampFile)' == ''">
				<CodesignStampFile Condition="'%(_CodesignItems.IsInputDirectory)' != 'true'">%(_CodesignItems.CodesignStampPath)\%(_CodesignItems.CodesignRelativeAppBundlePath)</CodesignStampFile>
				<CodesignStampFile Condition="'%(_CodesignItems.IsInputDirectory)' == 'true'">%(_CodesignItems.CodesignStampPath)\%(_CodesignItems.CodesignRelativeAppBundlePath)\.directory-stamp</CodesignStampFile>
			</_CodesignItems>
		</ItemGroup>
	</Target>

	<!-- sign the app bundle and anything inside that needs signing -->
	<!-- This target does not have Inputs/Outputs, because computing what needs signing or not is quite complex:
		* If any file inside a directory has been modified, we need to (re)sign
		* If any file or directory inside a directory needs to be signed, then the containing directory must be signed as well
		This logic is implemented in the Codesign task.
	-->
	<Target Name="_CodesignAppBundle"
			DependsOnTargets="$(_CodesignAppBundleDependsOn)"
		>

		<Codesign
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			Resources="@(_CodesignItems)"
			ToolExe="$(CodesignExe)"
			ToolPath="$(CodesignPath)"
			>
		</Codesign>
	</Target>

	<!-- LinkMode -->
	<PropertyGroup>
		<_ComputeLinkModeDependsOn>
			$(_ComputeLinkModeDependsOn);
			_DetectSdkLocations;
		</_ComputeLinkModeDependsOn>
	</PropertyGroup>
	<Target Name="_ComputeLinkMode" DependsOnTargets="$(_ComputeLinkModeDependsOn)">
		<PropertyGroup>
			<_LinkMode Condition="'$(_LinkMode)' == '' And '$(_PlatformName)' == 'macOS'">$(LinkMode)</_LinkMode>
			<_LinkMode Condition="'$(_LinkMode)' == '' And '$(_PlatformName)' != 'macOS'">$(MtouchLink)</_LinkMode>
			<_LinkMode Condition="'$(_LinkMode)' == ''">$(_DefaultLinkMode)</_LinkMode> <!-- Let the .NET targets chime in -->
			<_LinkMode Condition="'$(_LinkMode)' == '' And '$(_PlatformName)' == 'macOS'">None</_LinkMode> <!-- Linking is off by default for macOS apps -->
			<_LinkMode Condition="'$(_LinkMode)' == '' And '$(_PlatformName)' != 'macOS'">SdkOnly</_LinkMode> <!-- Default linking is SdkOnly for iOS/tvOS/watchOS apps -->
		</PropertyGroup>
	</Target>

	<Target Name="_ExtendAppExtensionReferences" DependsOnTargets="_ResolveAppExtensionReferences" Condition=" '@(AdditionalAppExtensions)' != ''">
	<!-- The idea here is that after _ResolveAppExtensionReferences we inject the 3rd party extensions into the list being processed later for embedding and code signing.
		- _ResolvedAppExtensionReferences is an item group of the path, so that's easy.
		- _AppExtensionCodesignProperties less so. It is generated by reading codesign.items generated by the c# tasks during build, which we don't have. 
		We also don't have a concrete list of types that get serialized, so I dug for every property referenced and set what I believe are sane values.-->
		<ItemGroup>
			<_ResolvedAppExtensionReferences Include="%(AdditionalAppExtensions.Identity)/%(AdditionalAppExtensions.BuildOutput)/%(AdditionalAppExtensions.Name).appex" />

			<_AppExtensionCodesignProperties Include="%(AdditionalAppExtensions.Name).appex">
				<Entitlements Condition="Exists('%(AdditionalAppExtensions.Identity)/%(AdditionalAppExtensions.Name).entitlements')">%(AdditionalAppExtensions.Identity)/%(AdditionalAppExtensions.Name).entitlements</Entitlements>
				<SigningKey>$(CodesignKey)</SigningKey>
				<Keychain>$(CodesignKeychain)</Keychain>
				<DisableTimestamp>False</DisableTimestamp>
				<DisableTimestamp Condition="'$(_SdkIsSimulator)' == 'true' Or '$(_BundlerDebug)' == 'true'">True</DisableTimestamp>
				<CodesignAllocate>$(_CodesignAllocate)</CodesignAllocate>
				<ResourceRules>$(CodesignResourceRules)</ResourceRules>
				<NativeExecutable>%(AdditionalAppExtensions.Filename)</NativeExecutable>
			</_AppExtensionCodesignProperties> 
		</ItemGroup>
	</Target>

	<Target Name="_PrepareResourceRules" DependsOnTargets="_DetectSdkLocations;_GenerateBundleName">
		<PrepareResourceRules
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '$(CodesignResourceRules)' != '' And '$(ComputedPlatform)' == 'iPhone'"
			AppBundleDir="$(AppBundleDir)"
			ResourceRules="$(CodesignResourceRules)"
			SdkVersion="$(_SdkVersion)"
			>
			<Output TaskParameter="PreparedResourceRules" PropertyName="_PreparedResourceRules"/>
		</PrepareResourceRules>
	</Target>

	<!-- App extensions -->

	<Target Name="_AssignAppExtensionConfiguration" Condition="'@(_AppExtensionReference)' != ''">
		<!-- assign configs if building a solution file -->
		<AssignProjectConfiguration
			ProjectReferences = "@(_AppExtensionReference)"
			SolutionConfigurationContents = "$(CurrentSolutionConfigurationContents)"
			Condition="'$(CurrentSolutionConfigurationContents)' != ''">

			<Output TaskParameter="AssignedProjects" ItemName="_AppExtensionReferenceWithConfiguration"/>
		</AssignProjectConfiguration>

		<!-- Else, just -->
		<CreateItem Include="@(_AppExtensionReference)"
					Condition="'$(CurrentSolutionConfigurationContents)' == ''">
			<Output TaskParameter="Include" ItemName="_AppExtensionReferenceWithConfiguration"/>
		</CreateItem>
	</Target>

	<Target Name="_SeparateAppExtensionReferences" BeforeTargets="AssignProjectConfiguration">
		<CreateItem Include="@(ProjectReference)" PreserveExistingMetadata="true" Condition="'%(Identity)' != '' And '%(ProjectReference.IsAppExtension)' == 'true'">
			<Output ItemName="_AppExtensionReference" TaskParameter="Include" />
		</CreateItem>

		<ItemGroup>
			<ProjectReference Remove="@(_AppExtensionReference)" />
		</ItemGroup>
	</Target>

	<!-- Split App Extension projects into 2 lists
		_AppExtensionReferenceWithConfigurationExistent: Projects existent on disk
		_AppExtensionReferenceWithConfigurationNonExistent: Projects non-existent on disk -->
	<Target Name="_SplitAppExtensionReferencesByExistent" DependsOnTargets="_AssignAppExtensionConfiguration">
		<CreateItem Include="@(_AppExtensionReferenceWithConfiguration)" Condition="'@(_AppExtensionReferenceWithConfiguration)' != ''">
			<Output TaskParameter="Include" ItemName="_AppExtensionReferenceWithConfigurationExistent"
				Condition="Exists ('%(_AppExtensionReferenceWithConfiguration.Identity)')"/>

			<Output TaskParameter="Include" ItemName="_AppExtensionReferenceWithConfigurationNonExistent"
				Condition="!Exists ('%(_AppExtensionReferenceWithConfiguration.Identity)')"/>
		</CreateItem>
	</Target>

	<Target Name="_ResolveAppExtensionReferences" DependsOnTargets="_SplitAppExtensionReferencesByExistent">
		<PropertyGroup>
			<!-- When building a .sln with msbuild, the dependent projects may not be built. So, always build
			     the referenced projects unless building from IDE. -->
			<_BuildReferencedExtensionProjects Condition="'$(BuildingInsideVisualStudio)' != 'true'">true</_BuildReferencedExtensionProjects>
		</PropertyGroup>

		<!-- If the referenced projects have already been built, then just get the target paths -->
		<MSBuild
			Projects="@(_AppExtensionReferenceWithConfigurationExistent)"
			Targets="GetBundleTargetPath"
			Properties="%(_AppExtensionReferenceWithConfigurationExistent.SetConfiguration); %(_AppExtensionReferenceWithConfigurationExistent.SetPlatform)"
			Condition="'@(_AppExtensionReferenceWithConfigurationExistent)' != '' and '$(_BuildReferencedExtensionProjects)' != 'true'">

			<Output TaskParameter="TargetOutputs" ItemName="_ResolvedAppExtensionReferences" Condition="'%(_AppExtensionReferenceWithConfigurationExistent.ReferenceOutputAssembly)' != 'false'"/>
		</MSBuild>

		<!-- Build the referenced project if required -->
		<MSBuild
			Projects="@(_AppExtensionReferenceWithConfigurationExistent)"
			Properties="%(_AppExtensionReferenceWithConfigurationExistent.SetConfiguration); %(_AppExtensionReferenceWithConfigurationExistent.SetPlatform)"
			Condition="'@(_AppExtensionReferenceWithConfigurationExistent)' != '' and '$(_BuildReferencedExtensionProjects)' == 'true' ">

			<Output TaskParameter="TargetOutputs" ItemName="_ResolvedAppExtensionReferences" Condition="'%(_AppExtensionReferenceWithConfigurationExistent.ReferenceOutputAssembly)' != 'false'"/>
		</MSBuild>

		<Warning Text="Referenced $(_PlatformName) App Extension Project %(_AppExtensionReferenceWithConfigurationNonExistent.Identity) not found, ignoring."
			 Condition="'@(_AppExtensionReferenceWithConfigurationNonExistent)' != ''"/>
	</Target>

	<Target Name="_PlaceAppExtensions" DependsOnTargets="_ExtendAppExtensionReferences;_ResolveAppExtensionReferences">
		<ItemGroup>
			<!-- Add a 'ContainerName' metadata to indicate where the extension should go inside the container's app bundle -->
			<_ResolvedAppExtensionReferences Condition="'%(_ResolvedAppExtensionReferences.Extension)' == '.appex'">
				<ContainerName>PlugIns</ContainerName>
			</_ResolvedAppExtensionReferences>
			<_ResolvedAppExtensionReferences Condition="'%(_ResolvedAppExtensionReferences.Extension)' == '.xpc'">
				<ContainerName>XPCServices</ContainerName>
			</_ResolvedAppExtensionReferences>
		</ItemGroup>

		<PropertyGroup>
			<_AppExtensionRoot Condition="'$(_PlatformName)' == 'macOS'">$(_AppBundlePath)Contents\</_AppExtensionRoot>
			<_AppExtensionRoot Condition="'$(_PlatformName)' != 'macOS'">$(_AppBundlePath)</_AppExtensionRoot>
		</PropertyGroup>
	</Target>

	<Target Name="_CopyAppExtensionsToBundle"
			DependsOnTargets="_ExtendAppExtensionReferences;_ResolveAppExtensionReferences;_PlaceAppExtensions"
			Inputs="@(_ResolvedAppExtensionReferences)"
			Outputs="$(_AppExtensionRoot)%(_ResolvedAppExtensionReferences.ContainerName)\%(_ResolvedAppExtensionReferences.FileName)%(_ResolvedAppExtensionReferences.Extension)"
			>
		<MakeDir
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			Directories="$(_AppExtensionRoot)%(_ResolvedAppExtensionReferences.ContainerName)"
		/>

		<Ditto
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			ToolExe="$(DittoExe)"
			ToolPath="$(DittoPath)"
			Source="@(_ResolvedAppExtensionReferences)"
			Destination="$(_AppExtensionRoot)%(_ResolvedAppExtensionReferences.ContainerName)\%(_ResolvedAppExtensionReferences.FileName)%(_ResolvedAppExtensionReferences.Extension)"
			TouchDestinationFiles="true"
		/>

		<!-- Delete any code signatures and dSYM dirs since they are now invalid -->
		<RemoveDir
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			Directories="$(_AppExtensionRoot)%(_ResolvedAppExtensionReferences.ContainerName)\%(_ResolvedAppExtensionReferences.FileName)%(_ResolvedAppExtensionReferences.Extension)\_CodeSignature;
						$(_AppBundlePath)..\%(_ResolvedAppExtensionReferences.FileName)%(_ResolvedAppExtensionReferences.Extension).dSYM"
		/>
	</Target>

	<Target Name="_GetNativeExecutableName" DependsOnTargets="_DetectAppManifest;_GenerateBundleName;_ReadAppManifest">
		<PropertyGroup>
			<_NativeExecutable Condition="'$(_PlatformName)' == 'iOS' Or '$(_PlatformName)' == 'tvOS' Or '$(_PlatformName)' == 'watchOS'">$(_AppBundlePath)$(_ExecutableName)</_NativeExecutable>
			<_NativeExecutable Condition="'$(_PlatformName)' == 'macOS' Or '$(_PlatformName)' == 'MacCatalyst'">$(_AppBundlePath)Contents\MacOS\$(_ExecutableName)</_NativeExecutable>
		</PropertyGroup>
	</Target>

	<Target Name="_ReadAppExtensionDebugSymbolProperties">
		<ReadItemsFromFile File="%(_ResolvedAppExtensionReferences.Identity)\..\dsym.items" Condition="Exists('%(_ResolvedAppExtensionReferences.Identity)\..\dsym.items')">
			<Output TaskParameter="Items" ItemName="_AppExtensionDebugSymbolProperties" />
		</ReadItemsFromFile>
	</Target>

	<Target Name="_GenerateAppExtensionDebugSymbols" Condition="'$(ComputedPlatform)' == 'iPhone' And '$(IsAppExtension)' == 'false'"
		DependsOnTargets="_ParseBundlerArguments;_CompileToNative;_ReadAppExtensionDebugSymbolProperties;_PlaceAppExtensions"
		Inputs="$(_AppExtensionRoot)PlugIns\%(_AppExtensionDebugSymbolProperties.Identity)\%(_AppExtensionDebugSymbolProperties.NativeExecutable)"
		Outputs="$(AppBundleDir)\..\%(_AppExtensionDebugSymbolProperties.Identity).dSYM\Contents\Info.plist">

		<RemoveDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Directories="$(AppBundleDir)\..\%(_AppExtensionDebugSymbolProperties.Identity).dSYM" />

		<!-- run dsymutil on the main bundle -->
		<DSymUtil
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '%(_AppExtensionDebugSymbolProperties.NoDSymUtil)' == 'false'"
			AppBundleDir="$(_AppExtensionRoot)PlugIns\%(_AppExtensionDebugSymbolProperties.Identity)"
			Architectures="%(_AppExtensionDebugSymbolProperties.CompiledArchitectures)"
			DSymDir="$(AppBundleDir)\..\%(_AppExtensionDebugSymbolProperties.Identity).dSYM"
			Executable="$(_AppExtensionRoot)PlugIns\%(_AppExtensionDebugSymbolProperties.Identity)\%(_AppExtensionDebugSymbolProperties.NativeExecutable)"
			ToolExe="$(DSymUtilExe)"
			ToolPath="$(DSymUtilPath)"
		>
		</DSymUtil>

		<!-- strip the debug symbols from the $(_NativeExecutable) -->
		<SymbolStrip
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '%(_AppExtensionDebugSymbolProperties.NoSymbolStrip)' == 'false'"
			Executable="$(_AppExtensionRoot)PlugIns\%(_AppExtensionDebugSymbolProperties.Identity)\%(_AppExtensionDebugSymbolProperties.NativeExecutable)"
			IsFramework="false"
			SymbolFile="%(_AppExtensionDebugSymbolProperties.SymbolsList)"
		>
		</SymbolStrip>

		<!-- touch the dSYM Info.plist so that its mtime is newer than the stripped $(_NativeExecutable) -->
		<Touch
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '%(_AppExtensionDebugSymbolProperties.NoSymbolStrip)' == 'false'"
			Files="$(AppBundleDir)\..\%(_AppExtensionDebugSymbolProperties.Identity).dSYM\Contents\Info.plist"
		>
		</Touch>
	</Target>

	<Target Name="_CopyUserFrameworkDebugSymbols" Condition="('$(_PlatformName)' == 'macOS') Or ('$(ComputedPlatform)' == 'iPhone' And '$(IsWatchApp)' == 'false')" DependsOnTargets="_CompileToNative;_ParseBundlerArguments;"
		Inputs="%(_FrameworkNativeReference.Name)"
		Outputs="$(AppBundleDir)\..\%(_FrameworkNativeReference.Filename).framework.dSYM\Contents\Info.plist"
		>

		<PropertyGroup>
			<_Source>$([System.IO.Path]::GetDirectoryName(%(_FrameworkNativeReference.Name)))\..\dSYMs\%(_FrameworkNativeReference.Filename).framework.dSYM\</_Source>
			<_Destination>$(AppBundleDir)\..\%(_FrameworkNativeReference.Filename).framework.dSYM</_Destination>
		</PropertyGroup>

		<RemoveDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Directories="$(_Destination)" />

		<!-- if available copy the provided user frameworks .dSYM -->
		<Ditto
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And Exists ('$(_Source)')"
			Source="$(_Source)"
			Destination="$(_Destination)"
		>
		</Ditto>
	</Target>

	<Target Name="_CalculateFrameworkDebugSymbolPath" DependsOnTargets="_CopyUserFrameworkDebugSymbols;_CollectFrameworks">
		<ItemGroup>
			<_Frameworks>
				<_Destination>$(AppBundleDir)\..\%(Filename).framework.dSYM</_Destination>
			</_Frameworks>
			<_Frameworks>
				<_DestinationExists>$([System.IO.File]::Exists('%(_Destination)'))</_DestinationExists>
			</_Frameworks>
		</ItemGroup>
	</Target>

	<Target Name="_GenerateFrameworkDebugSymbols" Condition="(('$(_PlatformName)' == 'macOS') Or (('$(ComputedPlatform)' == 'iPhone' And '$(IsWatchApp)' == 'false') and '$(IsMacEnabled)' == 'true'))" DependsOnTargets="_CopyUserFrameworkDebugSymbols;_CollectFrameworks;_CalculateFrameworkDebugSymbolPath"
		Inputs="%(_Frameworks.Identity)"
		Outputs="%(_Frameworks._Destination)\Contents\Info.plist"
		>

		<!-- Due to MSB4116 we can not check _DestinationExists in the condition for this target, thus all tasks must check it themselves -->

		<!-- run dsymutil on embedded frameworks -->
		<DSymUtil
			SessionId="$(BuildSessionId)"
			Condition="'$(_NoDSymUtil)' == 'false' and '%(_Frameworks._DestinationExists)' != 'true' "
			AppBundleDir="$(AppBundleDir)"
			Architectures=""
			DSymDir="%(_Frameworks._Destination)"
			Executable="%(_Frameworks.Identity)"
			ToolExe="$(DSymUtilExe)"
			ToolPath="$(DSymUtilPath)">
		</DSymUtil>

		<!-- strip embedded frameworks -->
		<SymbolStrip
			SessionId="$(BuildSessionId)"
			Condition="'$(_NoSymbolStrip)' == 'false' and '%(_Frameworks._DestinationExists)' != 'true' "
			Executable="%(_Frameworks.Identity)"
			IsFramework="true"
			SymbolFile="">
		</SymbolStrip>

		<!-- _GenerateDebugSymbols will run spotlight to index the dSYMs -->
	</Target>

	<Target Name="_PrepareDebugSymbolGeneration" Condition="('$(_PlatformName)' == 'macOS') Or ('$(ComputedPlatform)' == 'iPhone' And '$(IsWatchApp)' == 'false')" DependsOnTargets="_CompileToNative;_ParseBundlerArguments"
			Inputs="$(_NativeExecutable)" Outputs="$(DeviceSpecificOutputPath)dsym.items">

		<!-- For App Extensions, we delay running dsymutil & strip until it has been copied into the main app bundle... -->
		<!-- This needs to be executed in a task (and not here inside the target) so the execution always occur on the mac, even when the build is done from Windows -->
		<GetFullPath SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" RelativePath="$(_MtouchSymbolsList)">
			<Output TaskParameter="FullPath" PropertyName="_SymbolsListFullPath" />
		</GetFullPath>

		<!-- For App Extensions, we delay running dsymutil & strip until it has been copied into the main app bundle... -->
		<PropertyGroup>
			<!-- [System.IO.Path]::GetFileName() is safe to use -->
			<_NativeExecutableFileName>$([System.IO.Path]::GetFileName('$(_NativeExecutable)'))</_NativeExecutableFileName>
			<_AppBundleFileName>$([System.IO.Path]::GetFileName('$(AppBundleDir)'))</_AppBundleFileName>
		</PropertyGroup>

		<ItemGroup>
			<_AppExtensionDebugSymbolProperties Remove="@(_AppExtensionDebugSymbolProperties)" />

			<_AppExtensionDebugSymbolProperties Include="$(_AppBundleFileName)">
				<CompiledArchitectures>$(_CompiledArchitectures)</CompiledArchitectures>
				<NativeExecutable>$(_NativeExecutableFileName)</NativeExecutable>
				<NoSymbolStrip>$(_NoSymbolStrip)</NoSymbolStrip>
				<SymbolsList>$(_SymbolsListFullPath)</SymbolsList>
				<NoDSymUtil>$(_NoDSymUtil)</NoDSymUtil>
			</_AppExtensionDebugSymbolProperties>
		</ItemGroup>

		<WriteItemsToFile
			Condition="'$(IsMacEnabled)' == 'true'"
			Items="@(_AppExtensionDebugSymbolProperties)"
			ItemName="_AppExtensionDebugSymbolProperties"
			File="$(DeviceSpecificOutputPath)dsym.items"
			IncludeMetadata="true"
			Overwrite="true"
		/>
	</Target>

	<PropertyGroup>
		<GenerateDebugSymbolsDependsOn>
			_CompileToNative;
			_ParseBundlerArguments;
			_CalculateFrameworkDebugSymbolPath;
			_GenerateFrameworkDebugSymbols;
			_GenerateAppExtensionDebugSymbols;
			_PrepareDebugSymbolGeneration
		</GenerateDebugSymbolsDependsOn>
	</PropertyGroup>

	<Target Name="_GenerateDebugSymbols" Condition="('$(_PlatformName)' == 'macOS') Or ('$(ComputedPlatform)' == 'iPhone' And '$(IsWatchApp)' == 'false')" DependsOnTargets="$(GenerateDebugSymbolsDependsOn)"
		Inputs="$(_NativeExecutable)" Outputs="$(AppBundleDir).dSYM\Contents\Info.plist">

		<RemoveDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true' And '$(IsAppExtension)' == 'false'" Directories="$(AppBundleDir).dSYM" />
		<Delete SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true' And '$(IsAppExtension)' == 'false'" Files="$(DeviceSpecificOutputPath)*.bcsymbolmap" />

		<!-- run dsymutil on the main bundle -->
		<DSymUtil
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '$(_NoDSymUtil)' == 'false' And '$(IsAppExtension)' == 'false'"
			AppBundleDir="$(AppBundleDir)"
			Architectures="$(_CompiledArchitectures)"
			DSymDir="$(AppBundleDir).dSYM"
			Executable="$(_NativeExecutable)"
			ToolExe="$(DSymUtilExe)"
			ToolPath="$(DSymUtilPath)"
		>
		</DSymUtil>

		<!-- strip the debug symbols from the $(_NativeExecutable) -->
		<SymbolStrip
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '$(_NoSymbolStrip)' == 'false' And '$(IsAppExtension)' == 'false'"
			Executable="$(_NativeExecutable)"
			IsFramework="false"
			SymbolFile="$(_MtouchSymbolsList)"
		>
		</SymbolStrip>

		<!-- touch the dSYM Info.plist so that its mtime is newer than the stripped $(_NativeExecutable) -->
		<Touch
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '$(_NoSymbolStrip)' == 'false' And '$(IsAppExtension)' == 'false' And Exists('$(AppBundleDir).dSYM')"
			Files="$(AppBundleDir).dSYM\Contents\Info.plist"
		>
		</Touch>

		<!-- make sure spotlight indexes everything we've built -->
		<SpotlightIndexer
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '$(_NoDSymUtil)' == 'false' And '$(IsAppExtension)' == 'false'"
			Input="$(AppBundleDir)/../"
		>
		</SpotlightIndexer>
	</Target>

	<Target Name="_CreateDebugSettings" Condition="'$(_BundlerDebug)' == 'true' And '$(IsWatchApp)' == 'false' And '$(_PlatformName)' != 'MacCatalyst' And '$(_PlatformName)' != 'macOS'"
		DependsOnTargets="_CopyResourcesToBundle"
		Outputs="$(_AppBundlePath)Settings.bundle\Root.plist" >
		<CreateDebugSettings
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			AppBundleDir="$(AppBundleDir)"
			DebuggerPort="$(IOSDebuggerPort)"
			>
		</CreateDebugSettings>
	</Target>

	<Target Name="_CreateDebugConfiguration" Condition="'$(_BundlerDebug)' == 'true' And '$(IsWatchApp)' == 'false' And '$(_PlatformName)' != 'macOS'"
		DependsOnTargets="_CopyResourcesToBundle;_DetectDebugNetworkConfiguration"
		Outputs="$(_AppResourcesPath)MonoTouchDebugConfiguration.txt" >
		<MakeDir SessionId="$(BuildSessionId)" Condition="'$(IsMacEnabled)' == 'true'" Directories="$(_AppResourcesPath)" />
		<CreateDebugConfiguration
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			AppBundleDir="$(_AppResourcesPath)"
			DebugOverWiFi="$(IOSDebugOverWiFi)"
			DebugIPAddresses="$(_DebugIPAddresses)"
			DebuggerPort="$(IOSDebuggerPort)"
			SdkIsSimulator="$(_SdkIsSimulator)"
			>
		</CreateDebugConfiguration>
	</Target>

	<Target Name="_DetectDebugNetworkConfiguration" Condition="'$(_BundlerDebug)' == 'true'">
		<DetectDebugNetworkConfiguration
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			DebugOverWiFi="$(IOSDebugOverWiFi)"
			DebuggerHosts="$(IOSDebuggerHosts)"
			SdkIsSimulator="$(_SdkIsSimulator)"
			>

			<Output TaskParameter="DebugIPAddresses" PropertyName="_DebugIPAddresses" />
		</DetectDebugNetworkConfiguration>
	</Target>

	<PropertyGroup>
		<ArchiveDependsOn>
			_CoreArchive
		</ArchiveDependsOn>
	</PropertyGroup>

	<Target Name="Archive" Condition="'$(_CanArchive)' == 'true'" DependsOnTargets="$(ArchiveDependsOn)" />

	<Target Name="_CoreArchive" Condition="'$(ArchiveOnBuild)' == 'true'" DependsOnTargets="Codesign">
		<Error Text="Code signing must be enabled to create an Xcode archive." Condition="'$(_CodeSigningKey)' == '' And '$(_PlatformName)' != 'macOS' And '$(_PlatformName)' != 'MacCatalyst'" />

		<CollectITunesSourceFiles
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true' And '@(_ITunesSourceFile)' == '' And '$(_PlatformName)' != 'macOS' And '$(_PlatformName)' != 'MacCatalyst'"
			OutputPath="$(DeviceSpecificOutputPath)"
			>
			<Output TaskParameter="ITunesSourceFiles" PropertyName="_ITunesSourceFile"/>
		</CollectITunesSourceFiles>

		<Archive
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			AppBundleDir="$(AppBundleDir)"
			AppExtensionReferences="@(_ResolvedAppExtensionReferences)"
			CustomBundleName="$(_CustomBundleName)"
			InsightsApiKey="$(XamarinInsightsApiKey)"
			ITunesSourceFiles="@(_ITunesSourceFile)"
			OutputPath="$(DeviceSpecificOutputPath)"
			ProjectGuid="$(ProjectGuid)"
			ProjectName="$(MSBuildProjectName)"
			ProjectTypeGuids="$(ProjectTypeGuids)"
			SigningKey="$(_CodeSigningKey)"
			SolutionPath="$(SolutionPath)"
			TargetFrameworkMoniker="$(_ComputedTargetFrameworkMoniker)"
			WatchAppReferences="@(_ResolvedWatchAppReferences)"
			>
			<Output TaskParameter="ArchiveDir" PropertyName="ArchiveDir"/>
		</Archive>
	</Target>

	<Target Name="_GenerateBundleName" Condition="'$(_CanOutputAppBundle)' == 'true'" DependsOnTargets="_ComputeTargetArchitectures;_ParseBundlerArguments">
		<PropertyGroup Condition="'$(AppBundleDir)' == ''">
			<AppBundleDir Condition="'$(IsAppDistribution)' != 'true'">$(DeviceSpecificOutputPath)$(_AppBundleName)$(AppBundleExtension)</AppBundleDir>
			<AppBundleDir Condition="'$(IsAppDistribution)' == 'true'">$(ArchivePath)\Products\Applications\$(_AppBundleName)$(AppBundleExtension)</AppBundleDir>
		</PropertyGroup>
		<PropertyGroup>
			<_AppBundlePath>$(AppBundleDir)\</_AppBundlePath>
			<_AppResourcesRelativePath Condition="'$(_PlatformName)' == 'macOS' Or '$(_PlatformName)' == 'MacCatalyst'">Contents\Resources\</_AppResourcesRelativePath>
			<_AppResourcesRelativePath Condition="'$(_PlatformName)' == 'iOS' Or '$(_PlatformName)' == 'tvOS' Or '$(_PlatformName)' == 'watchOS'"></_AppResourcesRelativePath>
			<_AppResourcesPath>$(_AppBundlePath)$(_AppResourcesRelativePath)</_AppResourcesPath>

			<_AppContentsRelativePath Condition="'$(_PlatformName)' == 'macOS' Or '$(_PlatformName)' == 'MacCatalyst'">Contents\$(_CustomBundleName)</_AppContentsRelativePath>
			<_AppContentsRelativePath Condition="'$(_PlatformName)' == 'iOS' Or '$(_PlatformName)' == 'tvOS' Or '$(_PlatformName)' == 'watchOS'"></_AppContentsRelativePath>
			<_AppContentsPath>$(_AppBundlePath)$(_AppContentsRelativePath)</_AppContentsPath>

			<_AppFrameworksRelativePath Condition="'$(_PlatformName)' == 'macOS' Or '$(_PlatformName)' == 'MacCatalyst'">Contents\Frameworks\</_AppFrameworksRelativePath>
			<_AppFrameworksRelativePath Condition="'$(_PlatformName)' == 'iOS' Or '$(_PlatformName)' == 'tvOS' Or '$(_PlatformName)' == 'watchOS'">Frameworks\</_AppFrameworksRelativePath>
			<_AppFrameworksPath>$(_AppBundlePath)$(_AppFrameworksRelativePath)</_AppFrameworksPath>

			<_AppCodeSignatureRelativePath Condition="'$(_PlatformName)' == 'macOS' Or '$(_PlatformName)' == 'MacCatalyst'">Contents\</_AppCodeSignatureRelativePath>
			<_AppCodeSignatureRelativePath Condition="'$(_PlatformName)' == 'iOS' Or '$(_PlatformName)' == 'tvOS' Or '$(_PlatformName)' == 'watchOS'"></_AppCodeSignatureRelativePath>
			<_AppCodeSignaturePath>$(_AppBundlePath)$(_AppCodeSignatureRelativePath)</_AppCodeSignaturePath>

			<_AppPlugInsRelativePath Condition="'$(_PlatformName)' == 'macOS' Or '$(_PlatformName)' == 'MacCatalyst'">Contents\PlugIns\</_AppPlugInsRelativePath>
			<_AppPlugInsRelativePath Condition="'$(_PlatformName)' == 'iOS' Or '$(_PlatformName)' == 'tvOS' Or '$(_PlatformName)' == 'watchOS'">PlugIns\</_AppPlugInsRelativePath>
			<_AppPlugInsPath>$(_AppBundlePath)$(_AppPlugInsRelativePath)</_AppPlugInsPath>
		</PropertyGroup>
		<PropertyGroup Condition="'$(IsAppExtension)' == 'true'">
			<!-- needed for GetTargetPath/Build/Rebuild task outputs -->
			<_AppExtensionBundlePath>$(MSBuildProjectDirectory)\$(AppBundleDir)</_AppExtensionBundlePath>
		</PropertyGroup>
		<ItemGroup Condition="'$(IsAppExtension)' == 'true'">
			<_AppExtensionBundlePath Include="$(MSBuildProjectDirectory)\$(AppBundleDir)">
				<!-- We need this metadata to fix the source in VS -->
				<BuildSessionId>$(BuildSessionId)</BuildSessionId>
				<BuildServerPath>..\..\$(BuildAppName)\$(BuildSessionId)\$(AppBundleDir)</BuildServerPath>
			</_AppExtensionBundlePath>
		</ItemGroup>
	</Target>

	<Target Name="_CompileProductDefinition" Condition="$(CreatePackage)" DependsOnTargets="_WriteAppManifest;_ComputeTargetArchitectures">
		<CompileProductDefinition
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			AppManifest="$(_AppBundleManifestPath)"
			OutputDirectory="$(IntermediateOutputPath)"
			ProductDefinition="$(ProductDefinition)"
			TargetArchitectures="$(TargetArchitectures)"
		>
			<Output TaskParameter="CompiledProductDefinition" PropertyName="_CompiledProductDefinition" />
		</CompileProductDefinition>
	</Target>

	<Target Name="_CreateInstaller" Condition="'$(CreatePackage)' == 'true' And '$(_CanOutputAppBundle)' == 'true'" DependsOnTargets="Codesign;_CompileProductDefinition;_WriteAppManifest">
		<PropertyGroup>
			<PkgPackageDir Condition="'$(PkgPackageDir)' == ''">$(TargetDir)</PkgPackageDir>
		</PropertyGroup>
		<CreateInstallerPackage
			SessionId="$(BuildSessionId)"
			Condition="'$(IsMacEnabled)' == 'true'"
			AppBundleDir="$(AppBundleDir)"
			AppManifest="$(_AppBundleManifestPath)"
			EnablePackageSigning="$(EnablePackageSigning)"
			MainAssembly="$(TargetPath)"
			Name="$(AssemblyName)"
			OutputDirectory="$(PkgPackageDir)"
			PackageSigningKey="$(PackageSigningKey)"
			PackagingExtraArgs="$(PackagingExtraArgs)"
			PkgPackagePath="$(PkgPackagePath)"
			ProductDefinition="$(_CompiledProductDefinition)"
			ProjectPath="$(MSBuildProjectFullPath)"
		>
			<Output TaskParameter="PkgPackagePath" PropertyName="PkgPackagePath" />
		</CreateInstallerPackage>
	</Target>

	<PropertyGroup>
		<!-- Extensibility point for VS Publishing Workflow -->
		<_BeforeCreateIpaForDistributionDependsOn />

		<CreateIpaDependsOn>
			_BeforeCreateIpaForDistribution;
			_CompileEntitlements;
			_CoreCreateIpa;
			_PackageOnDemandResources;
			_ZipIpa
		</CreateIpaDependsOn>
	</PropertyGroup>

	<Target Name="_BeforeCreateIpaForDistribution" Condition="'$(IsAppDistribution)' == 'true'" DependsOnTargets="$(_BeforeCreateIpaForDistributionDependsOn)" />

	<Target Name="CreateIpa" Condition="'$(_CanArchive)' == 'true' And '$(_PlatformName)' != 'macOS' And '$(_PlatformName)' != 'MacCatalyst'" DependsOnTargets="$(CreateIpaDependsOn)" />

	<Import Project="$(MSBuildThisFileDirectory)Xamarin.Shared.ObjCBinding.targets" Condition="'$(IsBindingProject)' == 'true'" />

	<!-- Xamarin.ImplicitFacade.targets will detect if we need to add an implicit reference to netstandard.dll -->
	<Import Project="$(MSBuildThisFileDirectory)Xamarin.ImplicitFacade.targets" Condition="!('$(_PlatformName)' == 'macOS' And '$(TargetFrameworkName)' == 'System') And '$(UsingAppleNETSdk)' != 'true'"/>

	<Import Project="$(MSBuildThisFileDirectory)Xamarin.Shared.Stubs.targets" />

	<Import Project="$(MSBuildThisFileDirectory)$(MSBuildThisFileName).After.targets"
			Condition="Exists('$(MSBuildThisFileDirectory)$(MSBuildThisFileName).After.targets')"/>
</Project>
