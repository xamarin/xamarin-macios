//
// IManagedRegistrar.cs
//
// Authors:
//   Rolf Bjarne Kvinge
//
// Copyright 2023 Microsoft Corp

#if NET

#nullable enable

using System;
using System.Collections.Generic;

namespace ObjCRuntime {
	// The managed static registrar will generate/inject a type that implements this method
	// in every assembly it processes. At runtime we'll instantiate a singleton instance
	// of this type.
	// The managed static registrar will make this interface public when needed.
	interface IManagedRegistrar {
		// Find a function pointer for a given [UnmanagedCallersOnly] method.
		// The entryPoint parameter is the EntryPoint value in the attribute, but it's not used for lookup (only tracing/logging/error messages).
		// The 'id' is instead used - the values and the lookup tables are generated and injected by the managed static registrar at build time.
		IntPtr LookupUnmanagedFunction (string? entryPoint, int id);
		// Find a type given an id generated by the managed static registrar.
		// This method is the mirror method of LookupTypeId.
		RuntimeTypeHandle LookupType (uint id);
		// Find an id generated by the managed static registrar given an id.
		// This method is the mirror method of LookupType.
		uint LookupTypeId (RuntimeTypeHandle handle);
		// Called by the runtime when looking up a wrapper type given an interface type.
		// This method will be called once per assembly, and the implementation has to
		// add all the interface -> wrapper type mappings to the dictionary.
		void RegisterWrapperTypes (Dictionary<RuntimeTypeHandle, RuntimeTypeHandle> type);
		// Create an instance of a managed NSObject subclass for an existing Objective-C object.
		INativeObject? ConstructNSObject (RuntimeTypeHandle typeHandle, NativeHandle nativeHandle);
		// Create an instance of a managed NSObject subclass for an existing Objective-C object.
		INativeObject? ConstructINativeObject (RuntimeTypeHandle typeHandle, NativeHandle nativeHandle, bool owns);
	}
}

#endif // NET
