#  job that signs all the diff dotnet built artifacts.
parameters:

- name: condition
  default: succeeded()

- name: isPR
  type: boolean

steps:

- template: setup.yml
  parameters:
    isPR: ${{ parameters.isPR }}

- task: DownloadPipelineArtifact@2
  displayName: Download not notaraized build
  inputs:
    artifact: 'not-signed-package'
    patterns: '!*.pkg'
    allowFailedBuilds: true
    path: $(Build.SourcesDirectory)/package

- pwsh : |
    # Get the list of files to sign
    $msiFiles = Get-ChildItem -Path $(Build.SourcesDirectory)/package/ -Filter "*.msi"

    # Add those files to an array
    $SignFiles = @()
    foreach($msi in $msiFiles) {
        Write-Host "$($msi.FullName)"
        $SignFiles += @{ "SrcPath"="$($msi.FullName)"}
    }

    Write-Host "$msiFiles"

    # array of dicts
    $SignFileRecord = @(
      @{
        "Certs" = "400";
        "SignFileList" = $SignFiles;
      }
    )

    $SignFileList = @{
        "SignFileRecordList" = $SignFileRecord
    }

    # Write the json to a file
    ConvertTo-Json -InputObject $SignFileList -Depth 5 | Out-File -FilePath $(Build.ArtifactStagingDirectory)/MsiFiles2Notarize.json -Force
    dotnet $Env:MBSIGN_APPFOLDER/ddsignfiles.dll /filelist:$(Build.ArtifactStagingDirectory)/MsiFiles2Notarize.json
  displayName: 'Sign .msi'
  condition: ${{ and( eq(parameters.condition, true), eq(parameters.isPR, false)) }}

- pwsh: |
    mv $(Build.SourcesDirectory)/package/bundle.zip $(Build.ArtifactStagingDirectory)/not-signed-bundle.zip
    $bundlePath = "$(Build.ArtifactStagingDirectory)/bundle"
    unzip $(Build.ArtifactStagingDirectory)/not-signed-bundle.zip -d $bundlePath
    $patterns = @(
      "*.iOS.dll",
      "*.tvOS.dll",
      "*.Mac.dll", "*.macOS.dll", "*XamMac.dll",
      "*.MacCatalyst.dll",
      "*.WatchOS.dll"
    )
    $files = @()
    foreach ($p in $patterns) {
      $files += Get-ChildItem -Path $bundlePath -Recurse  -Filter $p
    }

    $SignFiles = @()
    foreach($f in $files) {
        Write-Host "$($f.FullName)"
        $SignFiles += @{ "SrcPath"="$($f.FullName)"}
    }

    $SignFileRecord = @(
      @{
        "Certs" = "400";
        "SignFileList" = $SignFiles;
      }
    )

    $SignFileList = @{
        "SignFileRecordList" = $SignFileRecord
    }

    # Write the json to a file
    ConvertTo-Json -InputObject $SignFileList -Depth 100 | Out-File -FilePath $(Build.ArtifactStagingDirectory)/bundle.json -Force
    dotnet $Env:MBSIGN_APPFOLDER/ddsignfiles.dll /filelist:$(Build.ArtifactStagingDirectory)/bundle.json
    # rezip and move back
    ditto -c -k --sequesterRsrc $bundlePath bundle.zip
    mv bundle.zip $(Build.SourcesDirectory)/package/bundle.zip
  displayName: 'Sign bundle.zip'
  workingDirectory: $(Build.ArtifactStagingDirectory)

- template: publish-nugets.yml

# always upload no matter what, since if we are not signing we need the artifact in the pipeline
- task: PublishPipelineArtifact@1
  displayName: 'Publish Notarized Dotnet Artifacts'
  inputs:
    targetPath: $(Build.SourcesDirectory)/package
    artifactName: dotnet-signed
  continueOnError: true
