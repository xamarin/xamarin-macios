include $(TOP)/mk/subdirs.mk

# Common cURL command:
# --fail: return an exit code if the connection succeeded, but returned an HTTP error code.
# --location: follow redirects
# --connect-timeout: if a connection doesn't happen within 15 seconds, then fail (and potentially retry). This is lower than the default to not get stuck waiting for a long time in case something goes wrong (but instead retry).
# --verbose / --silent: no explanation needed.
# --show-error: show an error to the terminal even if asked to be --silent.
CURL = curl --fail --location --connect-timeout 15 $(if $(V),--verbose,--silent) --show-error
# --retry: retry download 20 times
# --retry-delay: wait 2 seconds between each retry attempt
# --retry-all-errors: ignore the definition of insanity and retry even for errors that seem like you'd get the same result (such as 404). This isn't the real purpose, because this will also retry errors that will get a different result (such as connection failures / resets), which apparently --retry doesn't cover.
CURL_RETRY = $(CURL) --retry 20 --retry-delay 2 --retry-all-errors

DOTNET_TFM=net8.0
DOTNET_MAJOR_VERSION:=$(firstword $(subst ., ,$(subst net,,$(DOTNET_TFM))))
# calculate commit distance and store it in a file so that we don't have to re-calculate it every time make is executed.

# Support for hardcoding a commit distance start offset.
#
# The default is to add X000, where X is the major .NET version: we need to
# publish different versions of our NuGets for different .NET version
# (example: we need to publish one NuGet with support for Xcode 14.3 for .NET
# 6, and another one for .NET 7) - and these need to have different versions,
# and ordered correctly (the .NET 7 version must have a higher version than
# the .NET 6 version), and ideally it would be possible to just look at the
# version to see which .NET version it's targeting. Adding X000 to the commit
# distance accomplishes all these goals (as long as the commit distance itself
# doesn't need more than 3 digits).
NUGET_VERSION_COMMIT_DISTANCE_START=$(DOTNET_MAJOR_VERSION)000
NUGET_VERSION_STABLE_COMMIT_DISTANCE_START=$(DOTNET_MAJOR_VERSION)000

-include $(TOP)/Make.config.inc
$(TOP)/Make.config.inc: $(TOP)/Make.config $(TOP)/mk/mono.mk
	$(Q) cd $(TOP) && \
		ALL_DOTNET_PLATFORMS="$(ALL_DOTNET_PLATFORMS)" \
		NUGET_VERSION_COMMIT_DISTANCE_START=$(NUGET_VERSION_COMMIT_DISTANCE_START) \
		NUGET_VERSION_STABLE_COMMIT_DISTANCE_START=$(NUGET_VERSION_STABLE_COMMIT_DISTANCE_START) \
		./create-make-config.sh

include $(TOP)/Make.versions

APIDIFF_REFERENCES_iOS=https://dl.internalx.com/wrench/xcode14.3/97731c92cc6d147825c1a39ed2c5c530a5f9a12b/7611701/package/bundle.zip
APIDIFF_REFERENCES_Mac=https://dl.internalx.com/wrench/xcode14.3/97731c92cc6d147825c1a39ed2c5c530a5f9a12b/7611701/package/bundle.zip
APIDIFF_REFERENCES_DOTNET_iOS=https://dl.internalx.com/wrench/7.0.3xx/43ae6c749407e47fdf5fa07295119b87f7328ea6/8004688/package/bundle.zip
APIDIFF_REFERENCES_DOTNET_tvOS=https://dl.internalx.com/wrench/7.0.3xx/43ae6c749407e47fdf5fa07295119b87f7328ea6/8004688/package/bundle.zip
APIDIFF_REFERENCES_DOTNET_macOS=https://dl.internalx.com/wrench/7.0.3xx/43ae6c749407e47fdf5fa07295119b87f7328ea6/8004688/package/bundle.zip
APIDIFF_REFERENCES_DOTNET_MacCatalyst=https://dl.internalx.com/wrench/7.0.3xx/43ae6c749407e47fdf5fa07295119b87f7328ea6/8004688/package/bundle.zip

PACKAGE_HEAD_REV=$(shell git rev-parse HEAD)

#
# /!\ README /!\
#
# A release branch requires updating some variables.
# This is done in Make.versions, not here.
#

ifeq ($(BRANCH_NAME),)
# BRANCH_NAME is set in Jenkins, so this is for local builds.
CURRENT_BRANCH:=$(shell git rev-parse --abbrev-ref HEAD)
else
CURRENT_BRANCH:=$(BRANCH_NAME)
endif
CURRENT_BRANCH_SED_ESCAPED:=$(subst |,\|,$(subst &,\&,$(subst $$,\$$,$(subst /,\/,$(CURRENT_BRANCH)))))
# The branch name in the nuget version has to be alphanumeric, and we follow the semantic versioning spec,
# which defines "alphanumeric" as the letters, numbers and the dash character (and nothing else).
# So here we replace all non-alphanumeric characters in the branch name with a dash.
CURRENT_BRANCH_ALPHANUMERIC:=$(shell export LANG=C; printf "%s" "$(CURRENT_BRANCH)" | tr -c '[a-zA-Z0-9-]' '-')

# Get the current hash
CURRENT_HASH:=$(shell git log -1 --pretty=%h)
CURRENT_HASH_LONG:=$(shell git log -1 --pretty=%H)

# Get the pull request number, if this is a pull request
# Jenkins may set either CHANGE_ID or ghprbPullId
# Azure Devops sets SYSTEM_PULLREQUEST_PULLREQUESTNUMBER
ifneq ($(CHANGE_ID),)
PULL_REQUEST_ID=$(CHANGE_ID)
else ifneq ($(ghprbPullId),)
PULL_REQUEST_ID=$(ghprbPullId)
else ifneq ($(SYSTEM_PULLREQUEST_PULLREQUESTNUMBER),)
PULL_REQUEST_ID=$(SYSTEM_PULLREQUEST_PULLREQUESTNUMBER)
endif

# We have three types of branches:
#
# 1. Release (stable) branches. These have stable versioning (no prerelease identifiers).
# 2. Pre-release branches. These have stable versioning + prerelease identifiers.
# 3. Any other branches, These have CI/PR versioning.
#
# * A PR branch (case 3 above) is identified by the PULL_REQUEST_ID variable
#   (set in the environment). This takes precedence over any other variable.
# * Otherwise a release branch (case 1 above) is identified by setting the
#   NUGET_RELEASE_BRANCH variable to the name of the release branch (this
#   seems redundant: why should a branch name itself? but it's important if
#   another branch is created from the release branch: that other branch might
#   be any other random branch for whatever purpose, and shouldn't be
#   considered a release branch just because someone forgot to unset a
#   variable).
# * Otherwise a prerelease branch (case 2 above) is identified by the
#   NUGET_HARDCODED_PRERELEASE_IDENTIFIER variable, which is used to hardcode
#   a prerelease version. Note that NUGET_HARDCODED_PRERELEASE_BRANCH must
#   also be set to the name of the current branch, otherwise
#   NUGET_HARDCODED_PRERELEASE_IDENTIFIER will be ignored.
# * Otherwise we're a CI branch (case 3 above).

## If this branch is a release branch, set NUGET_RELEASE_BRANCH to the exact branch name (so that any other branches won't become release branches just by branching off from a release branch).
## Example: release/6.0.3xx
# NUGET_RELEASE_BRANCH=

## If this is a pre-release (alpha, beta, rc, xcode, etc.) branch, set NUGET_HARDCODED_PRERELASE_BRANCH to the exact branch name. Also set NUGET_HARDCODED_PRELEASE_IDENTIFIER to the prerelease identifier to use.
## Example:
##   NUGET_HARDCODED_PRERELEASE_BRANCH=release/6.0.3xx-rc3
##   NUGET_HARDCODED_PRERELEASE_IDENTIFIER=rc.3
## Example 2: we might sometimes make 'main' a prerelease branch:
##   NUGET_HARDCODED_PRERELEASE_BRANCH=main
##   NUGET_HARDCODED_PRERELEASE_IDENTIFIER=rc.4
## In this case, when we create an actual rc4 branch, the value for
## NUGET_HARDCODED_PRERELEASE_IDENTIFIER in main must be changed to "rc.5" (or
## anything else), while the value for NUGET_HARDCODED_PRERELEASE_BRANCH in
## the rc4 branch will become the rc4 branch name. The value in main must
## change *first*, otherwise we'll produce builds with the same version from
## two different branches (which is very, very bad).
##
## Note that the prerelease identifier should be as short as possible, because otherwise
## the resulting package name can become too long for MSIs.
NUGET_HARDCODED_PRERELEASE_IDENTIFIER=net8-rc2
NUGET_HARDCODED_PRERELEASE_BRANCH=net8.0

# compute the alphanumeric version of branch names
NUGET_RELEASE_BRANCH_ALPHANUMERIC:=$(shell export LANG=C; printf "%s" "$(NUGET_RELEASE_BRANCH)" | tr -c '[a-zA-Z0-9-]' '-')
NUGET_HARDCODED_PRERELEASE_BRANCH_ALPHANUMERIC:=$(shell export LANG=C; printf "%s" "$(NUGET_HARDCODED_PRERELEASE_BRANCH)" | tr -c '[a-zA-Z0-9-]' '-')

# Compute the prerelease identifier based on the variables above
# DO NOT MODIFY THE BELOW CONDITIONS TO HARDCODE A VERSION NUMBER FOR (PRE)RELEASE BRANCHES.
# READ INSTRUCTIONS ABOVE INSTEAD.
ifneq ($(PULL_REQUEST_ID),)
# we're a PR, so PR versioning
NUGET_PRERELEASE_IDENTIFIER=-ci.pr.gh$(PULL_REQUEST_ID)
else ifeq ($(NUGET_RELEASE_BRANCH_ALPHANUMERIC),$(CURRENT_BRANCH_ALPHANUMERIC))
# this is a release branch, so no prerelease identifier
NUGET_PRERELEASE_IDENTIFIER=
else ifeq ($(NUGET_HARDCODED_PRERELEASE_BRANCH_ALPHANUMERIC),$(CURRENT_BRANCH_ALPHANUMERIC))
# this is a prerelease branch!
NUGET_PRERELEASE_IDENTIFIER=-$(NUGET_HARDCODED_PRERELEASE_IDENTIFIER)
else
# this is a CI branch!
NUGET_PRERELEASE_IDENTIFIER=-ci.$(CURRENT_BRANCH_ALPHANUMERIC)
endif

NUGET_BUILD_METADATA=sha.$(CURRENT_HASH)

IOS_PRODUCT=Xamarin.iOS
IOS_PACKAGE_NAME=Xamarin.iOS
IOS_PACKAGE_NAME_LOWER=$(shell echo $(IOS_PACKAGE_NAME) | tr "[:upper:]" "[:lower:]")
IOS_PACKAGE_VERSION_MAJOR=$(word 1, $(subst ., ,$(IOS_PACKAGE_VERSION)))
IOS_PACKAGE_VERSION_MINOR=$(word 2, $(subst ., ,$(IOS_PACKAGE_VERSION)))
IOS_PACKAGE_VERSION_REV:=$(word 3, $(subst ., ,$(IOS_PACKAGE_VERSION)))
IOS_PACKAGE_VERSION_BUILD=$(IOS_COMMIT_DISTANCE)
IOS_PACKAGE_UPDATE_ID=$(shell printf "2%02d%02d%02d%03d" $(IOS_PACKAGE_VERSION_MAJOR) $(IOS_PACKAGE_VERSION_MINOR) $(IOS_PACKAGE_VERSION_REV) $(IOS_PACKAGE_VERSION_BUILD))

IOS_NUGET=Microsoft.iOS
IOS_NUGET_VERSION=$(IOS_NUGET_OS_VERSION).$(IOS_NUGET_COMMIT_DISTANCE)
IOS_NUGET_VERSION_MAJOR=$(word 1, $(subst ., ,$(IOS_NUGET_VERSION)))
IOS_NUGET_VERSION_MINOR=$(word 2, $(subst ., ,$(IOS_NUGET_VERSION)))
IOS_NUGET_VERSION_PATCH=$(word 3, $(subst ., ,$(IOS_NUGET_VERSION)))
IOS_NUGET_VERSION_NO_METADATA=$(IOS_NUGET_VERSION)$(NUGET_PRERELEASE_IDENTIFIER)
IOS_NUGET_VERSION_FULL=$(IOS_NUGET_VERSION_NO_METADATA)+$(NUGET_BUILD_METADATA)

IOS_WINDOWS_NUGET=Microsoft.iOS.Windows
IOS_WINDOWS_NUGET_VERSION_MAJOR=$(IOS_NUGET_VERSION_MAJOR)
IOS_WINDOWS_NUGET_VERSION_MINOR=$(IOS_NUGET_VERSION_MINOR)
IOS_WINDOWS_NUGET_VERSION_PATCH=$(IOS_NUGET_VERSION_PATCH)
IOS_WINDOWS_NUGET_VERSION_NO_METADATA=$(IOS_NUGET_VERSION_NO_METADATA)
IOS_WINDOWS_NUGET_VERSION_FULL=$(IOS_NUGET_VERSION_FULL)

TVOS_NUGET=Microsoft.tvOS
TVOS_NUGET_VERSION=$(TVOS_NUGET_OS_VERSION).$(TVOS_NUGET_COMMIT_DISTANCE)
TVOS_NUGET_VERSION_MAJOR=$(word 1, $(subst ., ,$(TVOS_NUGET_VERSION)))
TVOS_NUGET_VERSION_MINOR=$(word 2, $(subst ., ,$(TVOS_NUGET_VERSION)))
TVOS_NUGET_VERSION_PATCH=$(word 3, $(subst ., ,$(TVOS_NUGET_VERSION)))
TVOS_NUGET_VERSION_NO_METADATA=$(TVOS_NUGET_VERSION)$(NUGET_PRERELEASE_IDENTIFIER)
TVOS_NUGET_VERSION_FULL=$(TVOS_NUGET_VERSION_NO_METADATA)+$(NUGET_BUILD_METADATA)

WATCHOS_NUGET=Microsoft.watchOS
WATCHOS_NUGET_VERSION=$(WATCHOS_NUGET_OS_VERSION).$(WATCHOS_NUGET_COMMIT_DISTANCE)
WATCHOS_NUGET_VERSION_MAJOR=$(word 1, $(subst ., ,$(WATCHOS_NUGET_VERSION)))
WATCHOS_NUGET_VERSION_MINOR=$(word 2, $(subst ., ,$(WATCHOS_NUGET_VERSION)))
WATCHOS_NUGET_VERSION_PATCH=$(word 3, $(subst ., ,$(WATCHOS_NUGET_VERSION)))
WATCHOS_NUGET_VERSION_NO_METADATA=$(WATCHOS_NUGET_VERSION)$(NUGET_PRERELEASE_IDENTIFIER)
WATCHOS_NUGET_VERSION_FULL=$(WATCHOS_NUGET_VERSION_NO_METADATA)+$(NUGET_BUILD_METADATA)

MACCATALYST_NUGET=Microsoft.MacCatalyst
MACCATALYST_NUGET_VERSION=$(MACCATALYST_NUGET_OS_VERSION).$(MACCATALYST_NUGET_COMMIT_DISTANCE)
MACCATALYST_NUGET_VERSION_MAJOR=$(word 1, $(subst ., ,$(MACCATALYST_NUGET_VERSION)))
MACCATALYST_NUGET_VERSION_MINOR=$(word 2, $(subst ., ,$(MACCATALYST_NUGET_VERSION)))
MACCATALYST_NUGET_VERSION_PATCH=$(word 3, $(subst ., ,$(MACCATALYST_NUGET_VERSION)))
MACCATALYST_NUGET_VERSION_NO_METADATA=$(MACCATALYST_NUGET_VERSION)$(NUGET_PRERELEASE_IDENTIFIER)
MACCATALYST_NUGET_VERSION_FULL=$(MACCATALYST_NUGET_VERSION_NO_METADATA)+$(NUGET_BUILD_METADATA)

# Xcode version should have both a major and a minor version (even if the minor version is 0)
XCODE_VERSION=15.0
XCODE_URL=https://dl.internalx.com/internal-files/xcodes/Xcode_15_beta_6.xip
XCODE_DEVELOPER_ROOT=/Applications/Xcode_15.0.0-beta6.app/Contents/Developer
XCODE_PRODUCT_BUILD_VERSION:=$(shell /usr/libexec/PlistBuddy -c 'Print :ProductBuildVersion' $(XCODE_DEVELOPER_ROOT)/../version.plist 2>/dev/null || echo "    $(shell tput setaf 1 2>/dev/null)The required Xcode ($(XCODE_VERSION)) is not installed in $(basename $(basename $(XCODE_DEVELOPER_ROOT)))$(shell tput sgr0 2>/dev/null)" >&2)

# We define stable Xcode as the Xcode app being named like "Xcode_#.#[.#].app"
# and any other naming is deemed to be a beta. This is the safer approach: any
# errors are likely to be Xcode classified as a beta, when it's not, and in that
# case we'll accidentally release a prerelease version. This is not a problem:
# we fix it, and release the fixed version to stable. The opposite scenario is
# worse: when we release something as stable when it shouldn't be, so let's
# try to avoid that.
ifeq (OK,$(shell echo $(notdir $(abspath $(dir $(abspath $(dir $(XCODE_DEVELOPER_ROOT)))))) | sed -e 's/^Xcode[_0-9.]*[.]app$$/OK/'))
XCODE_IS_STABLE=true
XCODE_IS_PREVIEW=false
else
XCODE_IS_STABLE=false
XCODE_IS_PREVIEW=true
endif

# Tell both Xcode and our build logic which Xcode we're using.
export DEVELOPER_DIR=$(XCODE_DEVELOPER_ROOT)
export MD_APPLE_SDK_ROOT=$(abspath $(XCODE_DEVELOPER_ROOT)/../..)

# We don't need to be told there are workload updates
export DOTNET_CLI_WORKLOAD_UPDATE_NOTIFY_DISABLE=true
# We don't need to be told we're using preview packages (we pretty much always are).
export SuppressNETCoreSdkPreviewMessage=true

# Mono version embedded in XI/XM (NEEDED_MONO_VERSION/BRANCH) are specified in mk/mono.mk
include $(TOP)/mk/mono.mk
MONO_HASH := $(NEEDED_MONO_VERSION)

# Minimum Mono version for building XI/XM
MIN_MONO_VERSION=6.12.0.179
MAX_MONO_VERSION=6.12.99
MIN_MONO_URL=https://xamjenkinsartifact.azureedge.net/build-package-osx-mono/2020-02/185/dffa5ab92245f2419238a35b7c2052e9a24036b4/MonoFramework-MDK-6.12.0.179.macos10.xamarin.universal.pkg

# Minimum Mono version for Xamarin.Mac apps using the system mono
MIN_XM_MONO_VERSION=6.4.0.94
MIN_XM_MONO_URL=https://xamjenkinsartifact.azureedge.net/build-package-osx-mono/2019-06/77/c608cf3eafaea310e11af13cc9380d770112bb83/MonoFramework-MDK-6.4.0.94.macos10.xamarin.universal.pkg

# Minimum CMake version
MIN_CMAKE_URL=https://cmake.org/files/v3.6/cmake-3.6.2-Darwin-x86_64.dmg
MIN_CMAKE_VERSION=2.8.8

# ObjectiveSharpie min/max versions
MIN_SHARPIE_VERSION=3.5.73
MAX_SHARPIE_VERSION=3.5.99
MIN_SHARPIE_URL=https://download.visualstudio.microsoft.com/download/pr/0e3b855b-f555-46d0-a39b-ea2a45d5ec46/1694826efa1882979f8be51402dceadb/objectivesharpie-3.5.73.pkg

# Minimum OSX versions for building XI/XM
MIN_OSX_BUILD_VERSION=13.0
# Minimum OSX version for executing XI/XM tooling.
MIN_OSX_VERSION_FOR_IOS=10.15
MIN_OSX_VERSION_FOR_MAC=10.15

# Bump the *_NUGET_VERSION variables in Make.versions instead, because that makes sure the computed commit distance for the version is correct.
IOS_SDK_VERSION=$(word 1, $(subst ., ,$(IOS_NUGET_VERSION))).$(word 2, $(subst ., ,$(IOS_NUGET_VERSION)))
MACOS_SDK_VERSION=$(word 1, $(subst ., ,$(MACOS_NUGET_VERSION))).$(word 2, $(subst ., ,$(MACOS_NUGET_VERSION)))
WATCH_SDK_VERSION=$(word 1, $(subst ., ,$(WATCHOS_NUGET_VERSION))).$(word 2, $(subst ., ,$(WATCHOS_NUGET_VERSION)))
TVOS_SDK_VERSION=$(word 1, $(subst ., ,$(TVOS_NUGET_VERSION))).$(word 2, $(subst ., ,$(TVOS_NUGET_VERSION)))
MACCATALYST_SDK_VERSION=$(word 1, $(subst ., ,$(MACCATALYST_NUGET_VERSION))).$(word 2, $(subst ., ,$(MACCATALYST_NUGET_VERSION)))
MACCATALYST_MAC_SDK_VERSION=$(MACOS_SDK_VERSION)

MAX_IOS_DEPLOYMENT_TARGET=$(IOS_SDK_VERSION)
MAX_WATCH_DEPLOYMENT_TARGET=$(WATCH_SDK_VERSION)
MAX_TVOS_DEPLOYMENT_TARGET=$(TVOS_SDK_VERSION)

MAX_IOS_SIMULATOR_VERSION=$(IOS_SDK_VERSION)
MAX_TVOS_SIMULATOR_VERSION=$(TVOS_SDK_VERSION)
MAX_WATCH_SIMULATOR_VERSION=$(WATCH_SDK_VERSION)

# Minimum OS versions for running XI/XM apps.
MIN_IOS_SDK_VERSION=11.0
MIN_MACOS_SDK_VERSION=10.15
MIN_WATCHOS_SDK_VERSION=4.0
MIN_WATCHOS64_32_SDK_VERSION=5.1
MIN_WATCH_OS_VERSION=4.0
MIN_TVOS_SDK_VERSION=11.0
MIN_MACCATALYST_SDK_VERSION=13.1

# Minimum OS versions for .NET 8 support
DOTNET_MIN_IOS_SDK_VERSION=11.0
DOTNET_MIN_TVOS_SDK_VERSION=11.0
DOTNET_MIN_MACCATALYST_SDK_VERSION=13.1
DOTNET_MIN_MACOS_SDK_VERSION=10.15

# The min simulator version available in the Xcode we're using
MIN_IOS_SIMULATOR_VERSION=14.3
MIN_WATCHOS_SIMULATOR_VERSION=7.1
# This is the iOS version that matches the watchOS version (i.e same Xcode)
MIN_WATCHOS_COMPANION_SIMULATOR_VERSION=14.5
MIN_TVOS_SIMULATOR_VERSION=14.0
# These are the simulator package ids for the versions above
EXTRA_SIMULATORS=com.apple.pkg.iPhoneSimulatorSDK14_3 com.apple.pkg.AppleTVSimulatorSDK14_0 com.apple.pkg.iPhoneSimulatorSDK14_5 com.apple.pkg.WatchSimulatorSDK7_1

INCLUDE_IOS=1
INCLUDE_MAC=1
INCLUDE_WATCH=1
INCLUDE_TVOS=1
INCLUDE_MACCATALYST=1
INCLUDE_DEVICE=1
INCLUDE_DOTNET_WATCHOS=
INCLUDE_XAMARIN_LEGACY=1
INCLUDE_HOTRESTART=1

ENABLE_DOTNET=1

# disable source code install by default (it's enabled for CI builds)
ENABLE_INSTALL_SOURCE=

ifeq ($(shell test $(shell echo $(MIN_IOS_SDK_VERSION) | sed 's/[.].*//') -ge 11; echo $$?),0)
IOS_SUPPORTS_32BIT_ARCHITECTURES=
else
IOS_SUPPORTS_32BIT_ARCHITECTURES=1
endif

ifeq ($(shell test $(shell echo $(MIN_WATCHOS_SDK_VERSION) | sed 's/[.].*//') -ge 4; echo $$?),0)
WATCHOS_SUPPORTS_32BIT_ARCHITECTURES=
else
WATCHOS_SUPPORTS_32BIT_ARCHITECTURES=1
endif

-include $(TOP)/Make.config.local
-include $(TOP)/configure.inc

ifdef ENABLE_CCACHE
# Note the space at the end the line
CCACHE=ccache 
endif

XCODE_MAC_SDKROOT=$(XCODE_DEVELOPER_ROOT)/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk

# The MAC_* variables do not contain the -mmacosx-version-min flag on purpose: each usage must specify it separately.
MAC_CC=$(CCACHE)$(XCODE_DEVELOPER_ROOT)/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang -isysroot $(XCODE_MAC_SDKROOT)
MAC_CXX=$(CCACHE)$(XCODE_DEVELOPER_ROOT)/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++ -isysroot $(XCODE_MAC_SDKROOT)

MAC_INSTALL_VERSION ?= git
IOS_INSTALL_VERSION ?= git

ifneq ($(TESTS_USE_SYSTEM),)
IOS_DESTDIR ?= /
else
IOS_DESTDIR ?= $(TOP)/_ios-build
endif
IOS_TARGETDIR ?= $(IOS_DESTDIR)

USE_SOURCE_LINKS ?= 1

IOS_FRAMEWORK_DIR=/Library/Frameworks/Xamarin.iOS.framework
# Prefix used to install monotouch
ifndef MONOTOUCH_PREFIX
  MONOTOUCH_PREFIX=$(IOS_FRAMEWORK_DIR)/Versions/$(IOS_INSTALL_VERSION)
endif

XCODE_CC=$(CCACHE)$(XCODE_DEVELOPER_ROOT)/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang
XCODE_CXX=$(CCACHE)$(XCODE_DEVELOPER_ROOT)/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++

# make sure we have full paths. The patsubst function is to remove any trailing slash (this may leave the variable empty)
override IOS_DESTDIR := $(patsubst %/,%,$(abspath $(IOS_DESTDIR)))
override IOS_TARGETDIR := $(patsubst %/,%,$(abspath $(IOS_TARGETDIR)))
MONOTOUCH_PREFIX := $(abspath $(MONOTOUCH_PREFIX))

MONOTOUCH_MONO_PATH?=$(IOS_DESTDIR)$(MONOTOUCH_PREFIX)/lib/mono/Xamarin.iOS
MONOTOUCH_TV_MONO_PATH?=$(IOS_DESTDIR)$(MONOTOUCH_PREFIX)/lib/mono/Xamarin.TVOS
MONOTOUCH_WATCH_MONO_PATH?=$(IOS_DESTDIR)$(MONOTOUCH_PREFIX)/lib/mono/Xamarin.WatchOS
MONOTOUCH_MACCATALYST_MONO_PATH?=$(IOS_DESTDIR)$(MONOTOUCH_PREFIX)/lib/mono/Xamarin.MacCatalyst

IOS_PACKAGE_FILENAME=$(IOS_PACKAGE_NAME_LOWER)-$(IOS_PACKAGE_VERSION).pkg
IOS_PACKAGE_UTI=com.xamarin.$(IOS_PACKAGE_NAME_LOWER).pkg

IOS_COMMON_DEFINES=-DMONOTOUCH

IOS_CC=$(XCODE_CC)
IOS_CXX=$(XCODE_CXX)
SIMULATOR_BIN_PATH=$(XCODE_DEVELOPER_ROOT)/Platforms/iPhoneSimulator.platform/Developer/usr/bin
SIMULATOR_CC=$(IOS_CC)

CFLAGS= -Wall -fms-extensions -Werror -Wconversion -Wdeprecated -Wuninitialized -fstack-protector-strong -Wformat -Wformat-security -Werror=format-security

SIMULATOR_SDK=$(XCODE_DEVELOPER_ROOT)/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator$(IOS_SDK_VERSION).sdk

# Clang will by default emit objc_msgSend stubs in Xcode 14, which ld from earlier Xcodes doesn't understand.
# We disable this by passing -fno-objc-msgsend-selector-stubs to clang.
# We can probably remove this flag once we require developers to use Xcode 14.
# Ref: https://github.com/xamarin/xamarin-macios/issues/16223
OBJC_CFLAGS=-ObjC++ -std=c++14 -fno-exceptions -fno-objc-msgsend-selector-stubs

COMMON_SIMULATOR_CFLAGS=-mios-simulator-version-min=$(MIN_IOS_SDK_VERSION) -isysroot $(SIMULATOR_SDK) $(CFLAGS) -g $(IOS_COMMON_DEFINES)
SIMULATOR86_CFLAGS=$(COMMON_SIMULATOR_CFLAGS) -arch i386
SIMULATOR64_CFLAGS=$(COMMON_SIMULATOR_CFLAGS) -arch x86_64
SIMULATOR_ARM64_CFLAGS=$(COMMON_SIMULATOR_CFLAGS) -arch arm64
COMMON_SIMULATOR_OBJC_CFLAGS=-fobjc-abi-version=2 -fobjc-legacy-dispatch $(CFLAGS) $(OBJC_CFLAGS)
SIMULATOR86_OBJC_CFLAGS=$(COMMON_SIMULATOR_OBJC_CFLAGS) $(SIMULATOR86_CFLAGS)
SIMULATOR64_OBJC_CFLAGS=$(COMMON_SIMULATOR_OBJC_CFLAGS) $(SIMULATOR64_CFLAGS)
SIMULATOR_ARM64_OBJC_CFLAGS=$(COMMON_SIMULATOR_OBJC_CFLAGS) $(SIMULATOR_ARM64_CFLAGS)

MACCATALYST_COMMON_CFLAGS=-target x86_64-apple-ios$(MIN_MACCATALYST_SDK_VERSION)-macabi -arch x86_64 -g $(IOS_COMMON_DEFINES) \
	-isysroot $(XCODE_DEVELOPER_ROOT)/Platforms/MacOSX.platform/Developer/SDKs/MacOSX$(MACOS_SDK_VERSION).sdk \
	-isystem $(XCODE_DEVELOPER_ROOT)/Platforms/MacOSX.platform/Developer/SDKs/MacOSX$(MACOS_SDK_VERSION).sdk/System/iOSSupport/usr/include \
	-iframework $(XCODE_DEVELOPER_ROOT)/Platforms/MacOSX.platform/Developer/SDKs/MacOSX$(MACOS_SDK_VERSION).sdk/System/iOSSupport/System/Library/Frameworks
MACCATALYST_OBJC_CFLAGS=$(MACCATALYST_COMMON_CFLAGS) -fobjc-abi-version=2 -fobjc-legacy-dispatch $(OBJC_CFLAGS)
MACCATALYST_CFLAGS=$(MACCATALYST_COMMON_CFLAGS)

MACCATALYST_COMMON_CFLAGS=$(CFLAGS) -g $(IOS_COMMON_DEFINES) \
	-isysroot $(XCODE_DEVELOPER_ROOT)/Platforms/MacOSX.platform/Developer/SDKs/MacOSX$(MACOS_SDK_VERSION).sdk \
	-isystem $(XCODE_DEVELOPER_ROOT)/Platforms/MacOSX.platform/Developer/SDKs/MacOSX$(MACOS_SDK_VERSION).sdk/System/iOSSupport/usr/include \
	-iframework $(XCODE_DEVELOPER_ROOT)/Platforms/MacOSX.platform/Developer/SDKs/MacOSX$(MACOS_SDK_VERSION).sdk/System/iOSSupport/System/Library/Frameworks
MACCATALYST_COMMON_OBJC_CFLAGS=$(MACCATALYST_COMMON_CFLAGS) -fobjc-abi-version=2 -fobjc-legacy-dispatch $(OBJC_CFLAGS)
MACCATALYST_X86_64_OBJC_CFLAGS=$(MACCATALYST_COMMON_OBJC_CFLAGS) -target x86_64-apple-ios$(MIN_MACCATALYST_SDK_VERSION)-macabi -arch x86_64
MACCATALYST_X86_64_CFLAGS=$(MACCATALYST_COMMON_CFLAGS) -target x86_64-apple-ios$(MIN_MACCATALYST_SDK_VERSION)-macabi -arch x86_64
MACCATALYST_ARM64_OBJC_CFLAGS=$(MACCATALYST_COMMON_OBJC_CFLAGS) -target arm64-apple-ios$(MIN_MACCATALYST_SDK_VERSION)-macabi -arch arm64
MACCATALYST_ARM64_CFLAGS=$(MACCATALYST_COMMON_CFLAGS) -target arm64-apple-ios$(MIN_MACCATALYST_SDK_VERSION)-macabi -arch arm64

MONOTOUCH_SIMULATOR_SDK=$(MONOTOUCH_PREFIX)/SDKs/MonoTouch.iphonesimulator.sdk

DEVICE_BIN_PATH=$(XCODE_DEVELOPER_ROOT)/Toolchains/XcodeDefault.xctoolchain/usr/bin
DEVICE_CC=$(IOS_CC)
DEVICE_CXX=$(IOS_CXX)

IOS_CSC=$(SYSTEM_CSC) -features:strict -nostdlib -noconfig -r:$(MONOTOUCH_MONO_PATH)/System.dll -r:$(MONOTOUCH_MONO_PATH)/System.Core.dll -r:$(MONOTOUCH_MONO_PATH)/System.Xml.dll -r:$(MONOTOUCH_MONO_PATH)/mscorlib.dll -r:$(MONOTOUCH_MONO_PATH)/System.Net.Http.dll -r:$(MONOTOUCH_MONO_PATH)/Facades/System.Drawing.Common.dll -deterministic
TV_CSC=$(SYSTEM_CSC) -features:strict -nostdlib -noconfig -r:$(MONOTOUCH_TV_MONO_PATH)/System.dll -r:$(MONOTOUCH_TV_MONO_PATH)/System.Core.dll -r:$(MONOTOUCH_TV_MONO_PATH)/System.Xml.dll -r:$(MONOTOUCH_TV_MONO_PATH)/mscorlib.dll -r:$(MONOTOUCH_TV_MONO_PATH)/System.Net.Http.dll -r:$(MONOTOUCH_TV_MONO_PATH)/Facades/System.Drawing.Common.dll -deterministic
WATCH_CSC=$(SYSTEM_CSC) -features:strict -nostdlib -noconfig -r:$(MONOTOUCH_WATCH_MONO_PATH)/System.dll -r:$(MONOTOUCH_WATCH_MONO_PATH)/System.Core.dll -r:$(MONOTOUCH_WATCH_MONO_PATH)/System.Xml.dll -r:$(MONOTOUCH_WATCH_MONO_PATH)/mscorlib.dll -r:$(MONOTOUCH_WATCH_MONO_PATH)/System.Net.Http.dll -r:$(MONOTOUCH_WATCH_MONO_PATH)/Facades/System.Drawing.Common.dll -deterministic
MACCATALYST_CSC=$(SYSTEM_CSC) -features:strict -nostdlib -noconfig -r:$(MONOTOUCH_MACCATALYST_MONO_PATH)/System.dll -r:$(MONOTOUCH_MACCATALYST_MONO_PATH)/System.Core.dll -r:$(MONOTOUCH_MACCATALYST_MONO_PATH)/System.Xml.dll -r:$(MONOTOUCH_MACCATALYST_MONO_PATH)/mscorlib.dll -r:$(MONOTOUCH_MACCATALYST_MONO_PATH)/System.Net.Http.dll -r:$(MONOTOUCH_MACCATALYST_MONO_PATH)/Facades/System.Drawing.Common.dll -deterministic

DEVICE_OBJC_CFLAGS=$(OBJC_CFLAGS)

DEVICE_SDK=$(XCODE_DEVELOPER_ROOT)/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS$(IOS_SDK_VERSION).sdk
DEVICE7_CFLAGS= -arch armv7  -mno-thumb -miphoneos-version-min=$(MIN_IOS_SDK_VERSION) -isysroot $(DEVICE_SDK) $(CFLAGS) $(IOS_COMMON_DEFINES)
DEVICE7S_CFLAGS=-arch armv7s -mno-thumb -miphoneos-version-min=$(MIN_IOS_SDK_VERSION) -isysroot $(DEVICE_SDK) $(CFLAGS) $(IOS_COMMON_DEFINES)
DEVICE64_CFLAGS=-arch arm64             -miphoneos-version-min=7.0                    -isysroot $(DEVICE_SDK) $(CFLAGS) $(IOS_COMMON_DEFINES)
DEVICE7_OBJC_CFLAGS =$(DEVICE7_CFLAGS)  $(DEVICE_OBJC_CFLAGS)
DEVICE7S_OBJC_CFLAGS=$(DEVICE7S_CFLAGS) $(DEVICE_OBJC_CFLAGS)
DEVICE64_OBJC_CFLAGS=$(DEVICE64_CFLAGS) $(DEVICE_OBJC_CFLAGS)
MONOTOUCH_DEVICE_SDK=$(MONOTOUCH_PREFIX)/SDKs/MonoTouch.iphoneos.sdk

# iOS

XAMARIN_IOSSIMULATOR_SDK = $(MONOTOUCH_SIMULATOR_SDK)
XAMARIN_IPHONEOS_SDK     = $(MONOTOUCH_DEVICE_SDK)

# MacCatalyst

XAMARIN_MACCATALYST_SDK    = $(MONOTOUCH_PREFIX)/SDKs/Xamarin.MacCatalyst.sdk

# WatchOS 

XAMARIN_WATCHSIMULATOR_SDK = $(MONOTOUCH_PREFIX)/SDKs/Xamarin.WatchSimulator.sdk
XAMARIN_WATCHOS_SDK        = $(MONOTOUCH_PREFIX)/SDKs/Xamarin.WatchOS.sdk

SIMULATORWATCH_SDK           = $(XCODE_DEVELOPER_ROOT)/Platforms/WatchSimulator.platform/Developer/SDKs/WatchSimulator$(WATCH_SDK_VERSION).sdk
SIMULATORWATCH_CFLAGS        = -arch i386 -mwatchos-simulator-version-min=$(MIN_WATCHOS_SDK_VERSION) -isysroot $(SIMULATORWATCH_SDK) $(CFLAGS) -g $(IOS_COMMON_DEFINES)
SIMULATORWATCH64_CFLAGS      = -arch x86_64 -mwatchos-simulator-version-min=$(MIN_WATCHOS_SDK_VERSION) -isysroot $(SIMULATORWATCH_SDK) $(CFLAGS) -g $(IOS_COMMON_DEFINES)
SIMULATORWATCH_OBJC_CFLAGS   = $(SIMULATORWATCH_CFLAGS) $(COMMON_SIMULATOR_OBJC_CFLAGS) 
SIMULATORWATCH64_OBJC_CFLAGS = $(SIMULATORWATCH64_CFLAGS) $(COMMON_SIMULATOR_OBJC_CFLAGS) 

DEVICEWATCH_SDK         = $(XCODE_DEVELOPER_ROOT)/Platforms/WatchOS.platform/Developer/SDKs/WatchOS$(WATCH_SDK_VERSION).sdk
DEVICEWATCH_CFLAGS      = -arch armv7k -mwatchos-version-min=$(MIN_WATCHOS_SDK_VERSION) -isysroot $(DEVICEWATCH_SDK) $(CFLAGS) -fembed-bitcode $(IOS_COMMON_DEFINES)
DEVICEWATCH64_32_CFLAGS = -arch arm64_32 -mwatchos-version-min=$(MIN_WATCHOS64_32_SDK_VERSION) -isysroot $(DEVICEWATCH_SDK) $(CFLAGS) -fembed-bitcode $(IOS_COMMON_DEFINES)
DEVICEWATCH_OBJC_CFLAGS = $(DEVICEWATCH_CFLAGS) $(DEVICE_OBJC_CFLAGS)
DEVICEWATCH64_32_OBJC_CFLAGS = $(DEVICEWATCH64_32_CFLAGS) $(DEVICE_OBJC_CFLAGS)

# TVOS

XAMARIN_TVSIMULATOR_SDK    = $(MONOTOUCH_PREFIX)/SDKs/Xamarin.AppleTVSimulator.sdk
XAMARIN_TVOS_SDK           = $(MONOTOUCH_PREFIX)/SDKs/Xamarin.AppleTVOS.sdk

SIMULATORTV_SDK            = $(XCODE_DEVELOPER_ROOT)/Platforms/AppleTVSimulator.platform/Developer/SDKs/AppleTVSimulator$(TVOS_SDK_VERSION).sdk
SIMULATORTV_CFLAGS         = -arch x86_64 -mtvos-simulator-version-min=$(MIN_TVOS_SDK_VERSION) -isysroot $(SIMULATORTV_SDK) $(CFLAGS) -g $(IOS_COMMON_DEFINES)
SIMULATORTV_ARM64_CFLAGS   = -arch arm64  -mtvos-simulator-version-min=$(MIN_TVOS_SDK_VERSION) -isysroot $(SIMULATORTV_SDK) $(CFLAGS) -g $(IOS_COMMON_DEFINES)
SIMULATORTV_OBJC_CFLAGS    = $(SIMULATORTV_CFLAGS) $(COMMON_SIMULATOR_OBJC_CFLAGS) 
SIMULATORTV_ARM64_OBJC_CFLAGS = $(SIMULATORTV_ARM64_CFLAGS) $(COMMON_SIMULATOR_OBJC_CFLAGS)

DEVICETV_SDK               = $(XCODE_DEVELOPER_ROOT)/Platforms/AppleTVOS.platform/Developer/SDKs/AppleTVOS$(TVOS_SDK_VERSION).sdk
DEVICETV_CFLAGS            = -arch arm64 -mtvos-version-min=$(MIN_TVOS_SDK_VERSION) -isysroot $(DEVICETV_SDK) $(CFLAGS) $(IOS_COMMON_DEFINES)
DEVICETV_OBJC_CFLAGS       = $(DEVICETV_CFLAGS) $(DEVICE_OBJC_CFLAGS)

# macOS

XAMARIN_MACOS_SDK = $(MAC_FRAMEWORK_CURRENT_DIR)/SDKs/Xamarin.macOS.sdk

MAC_OBJC_CFLAGS= -mmacosx-version-min=$(MIN_MACOS_SDK_VERSION) -DMONOMAC -DMIN_XM_MONO_VERSION=\"$(MIN_XM_MONO_VERSION)\" $(CFLAGS) $(OBJC_CFLAGS)
MAC_CFLAGS = -mmacosx-version-min=$(MIN_MACOS_SDK_VERSION) -DMONOMAC -g -DMIN_XM_MONO_VERSION=\"$(MIN_XM_MONO_VERSION)\" $(CFLAGS)
MAC_LDFLAGS = -mmacosx-version-min=$(MIN_MACOS_SDK_VERSION) -framework AppKit

# paths to the modules we depend on, as variables, so people can put
# things in other places if they absolutely must.
MONO_PATH=$(TOP)/external/mono
TOUCH_UNIT_PATH=$(TOP)/external/Touch.Unit
OPENTK_PATH=$(TOP)/external/opentk
XAMARIN_MACDEV_PATH=$(TOP)/external/Xamarin.MacDev
MACCORE_PATH=$(TOP)/../maccore
MACIOS_BINARIES_PATH=$(TOP)/external/macios-binaries
IKVM_PATH=$(TOP)/external/ikvm-fork
MONOTOUCH_DIALOG_PATH=$(TOP)/external/MonoTouch.Dialog
API_TOOLS_PATH=$(TOP)/external/api-tools

MONO_PREFIX ?= /Library/Frameworks/Mono.framework/Versions/Current
SYSTEM_MCS=$(MONO_PREFIX)/bin/mcs
SYSTEM_CSC=$(MONO_PREFIX)/bin/csc
SYSTEM_SN=$(MONO_PREFIX)/bin/sn
SYSTEM_MONO=$(MONO_PREFIX)/bin/mono
SYSTEM_MONO32=$(MONO_PREFIX)/bin/mono32
SYSTEM_XBUILD=$(MONO_PREFIX)/bin/msbuild /p:Features=strict /m
SYSTEM_MSBUILD=unset MSBuildExtensionsPath && $(MONO_PREFIX)/bin/msbuild /p:Features=strict /m
SYSTEM_RESGEN=$(MONO_PREFIX)/bin/resgen

XIBUILD_EXE_PATH=$(abspath $(TOP)/tools/xibuild/bin/Debug/xibuild.exe)
SYSTEM_XIBUILD=$(SYSTEM_MONO) $(XIBUILD_EXE_PATH) $(XIBUILD_VERBOSITY)

PKG_CONFIG=$(MONO_PREFIX)/bin/pkg-config

MAC_PRODUCT=Xamarin.Mac
MAC_PACKAGE_NAME=xamarin.mac
MAC_PACKAGE_NAME_LOWER=$(shell echo $(MAC_PACKAGE_NAME) | tr "[:upper:]" "[:lower:]")

MAC_PACKAGE_VERSION_MAJOR=$(word 1, $(subst ., ,$(MAC_PACKAGE_VERSION)))
MAC_PACKAGE_VERSION_MINOR=$(word 2, $(subst ., ,$(MAC_PACKAGE_VERSION)))
MAC_PACKAGE_VERSION_REV=$(word 3, $(subst ., ,$(MAC_PACKAGE_VERSION)))
MAC_PACKAGE_VERSION_BUILD=$(word 4, $(subst ., ,$(MAC_PACKAGE_VERSION)))
MAC_PACKAGE_VERSION_MAJOR_MINOR=$(MAC_PACKAGE_VERSION_MAJOR).$(MAC_PACKAGE_VERSION_MINOR)
MAC_PACKAGE_UPDATE_ID=$(shell echo $(subst ., ,$(MAC_PACKAGE_VERSION).$(MAC_PACKAGE_VERSION_BUILD)) | awk '{printf "2%02d%02d%02d%03d",$$1,$$2,$$3,$$4}')
MAC_PACKAGE_TITLE=Xamarin $(MAC_PACKAGE_NAME) $(MAC_PACKAGE_VERSION)

MACOS_NUGET=Microsoft.macOS
MACOS_NUGET_VERSION=$(MACOS_NUGET_OS_VERSION).$(MACOS_NUGET_COMMIT_DISTANCE)
MACOS_NUGET_VERSION_MAJOR=$(word 1, $(subst ., ,$(MACOS_NUGET_VERSION)))
MACOS_NUGET_VERSION_MINOR=$(word 2, $(subst ., ,$(MACOS_NUGET_VERSION)))
MACOS_NUGET_VERSION_PATCH=$(word 3, $(subst ., ,$(MACOS_NUGET_VERSION)))
MACOS_NUGET_VERSION_NO_METADATA=$(MACOS_NUGET_VERSION)$(NUGET_PRERELEASE_IDENTIFIER)
MACOS_NUGET_VERSION_FULL=$(MACOS_NUGET_VERSION_NO_METADATA)+$(NUGET_BUILD_METADATA)

ifneq ($(TESTS_USE_SYSTEM),)
MAC_DESTDIR ?= /
else
MAC_DESTDIR ?= $(TOP)/_mac-build
endif
MAC_TARGETDIR ?= $(MAC_DESTDIR)

# make sure we have full paths. The patsubst function is to remove any trailing slash (this may leave the variable empty)
override MAC_DESTDIR := $(patsubst %/,%,$(abspath $(MAC_DESTDIR)))
override MAC_TARGETDIR := $(patsubst %/,%,$(abspath $(MAC_TARGETDIR)))

MAC_FRAMEWORK_DIR = /Library/Frameworks/Xamarin.Mac.framework
MAC_FRAMEWORK_VERSIONED_DIR = $(MAC_FRAMEWORK_DIR)/Versions/$(MAC_PACKAGE_VERSION)
MAC_FRAMEWORK_CURRENT_DIR = $(MAC_FRAMEWORK_DIR)/Versions/$(MAC_INSTALL_VERSION)

MOBILE_BCL_DIR = $(MAC_DESTDIR)$(MAC_FRAMEWORK_CURRENT_DIR)/lib/mono/Xamarin.Mac
MAC_mobile_CSC = $(SYSTEM_CSC) -features:strict -nostdlib -noconfig -r:$(MOBILE_BCL_DIR)/System.dll -r:$(MOBILE_BCL_DIR)/System.Core.dll -r:$(MOBILE_BCL_DIR)/System.Xml.dll -r:$(MOBILE_BCL_DIR)/mscorlib.dll -r:$(MOBILE_BCL_DIR)/System.Net.Http.dll -r:$(MOBILE_BCL_DIR)/Facades/System.Drawing.Common.dll -deterministic

FULL_BCL_DIR = $(MAC_DESTDIR)$(MAC_FRAMEWORK_CURRENT_DIR)/lib/mono/4.5
MAC_full_CSC = $(SYSTEM_CSC) -features:strict -nostdlib -noconfig -r:$(FULL_BCL_DIR)/System.dll -r:$(FULL_BCL_DIR)/System.Core.dll -r:$(FULL_BCL_DIR)/System.Xml.dll -r:$(FULL_BCL_DIR)/mscorlib.dll -r:$(FULL_BCL_DIR)/System.Net.Http.dll -r:$(FULL_BCL_DIR)/Facades/System.Drawing.Common.dll -deterministic

MAC_PACKAGE_FILENAME=$(MAC_PACKAGE_NAME_LOWER)-$(MAC_PACKAGE_VERSION).pkg
MAC_PACKAGE_DMG_FILENAME=$(MAC_PACKAGE_NAME_LOWER)-$(MAC_PACKAGE_VERSION).dmg
MAC_PACKAGE_DMG_DIRNAME="$(MAC_PACKAGE_TITLE)"
MAC_PACKAGE_UTI=com.$(MAC_PACKAGE_NAME_LOWER).pkg
MAC_PACKAGE_INSTALL_LOCATION=$(MAC_FRAMEWORK_VERSIONED_DIR)

TT = $(DOTNET) tool restore && $(DOTNET) t4

PRODUCT_KEY_PATH?=$(TOP)/product.snk

include $(TOP)/mk/quiet.mk

IOS_SOURCE=$(TOP)/src
IOS_BUILD_SOURCE=$(IOS_SOURCE)/build/ios/native
IOS_COMMON_BUILD_SOURCE=$(IOS_SOURCE)/build/common
MAC_SOURCE=$(TOP)/src
MAC_FULL_BUILD_SOURCE=$(MAC_SOURCE)/build/mac/full
MAC_MODERN_BUILD_SOURCE=$(MAC_SOURCE)/build/mac/mobile
MAC_COMMON_BUILD_SOURCE=$(MAC_SOURCE)/build/common

ifneq ($(BUILD_REVISION),)
IOS_CSC_FLAGS_XI=-pathmap:"$(abspath $(IOS_COMMON_BUILD_SOURCE))/=$(IOS_FRAMEWORK_DIR)/Versions/$(IOS_PACKAGE_VERSION)/src/Xamarin.iOS/" -pathmap:"$(abspath $(IOS_BUILD_SOURCE))/=$(IOS_FRAMEWORK_DIR)/Versions/$(IOS_PACKAGE_VERSION)/src/Xamarin.iOS/" -pathmap:"$(abspath $(IOS_SOURCE))/=$(IOS_FRAMEWORK_DIR)/Versions/$(IOS_PACKAGE_VERSION)/src/Xamarin.iOS/"
MAC_CSC_FLAGS_XM=-pathmap:"$(abspath $(MAC_COMMON_BUILD_SOURCE))/=$(MAC_FRAMEWORK_DIR)/Versions/$(MAC_PACKAGE_VERSION)/src/Xamarin.Mac/" -pathmap:"$(abspath $(MAC_FULL_BUILD_SOURCE))/=$(MAC_FRAMEWORK_DIR)/Versions/$(MAC_PACKAGE_VERSION)/src/Xamarin.Mac/" -pathmap:"$(abspath $(MAC_MODERN_BUILD_SOURCE))/=$(MAC_FRAMEWORK_DIR)/Versions/$(MAC_PACKAGE_VERSION)/src/Xamarin.Mac/" -pathmap:"$(abspath $(MAC_SOURCE))/=$(MAC_FRAMEWORK_DIR)/Versions/$(MAC_PACKAGE_VERSION)/src/Xamarin.Mac/"
endif

ifdef ENABLE_XAMARIN
-include $(MACCORE_PATH)/Make.config
endif

JENKINS_RESULTS_DIRECTORY ?= $(abspath $(TOP)/jenkins-results)

# Clone files instead of copying them on APFS file systems. Much faster.
CP:=$(shell df -t apfs / >/dev/null 2>&1 && echo "cp -c" || echo "cp")

# WORKAROUND, Ideally it should be xcode-$(XCODE_PRODUCT_BUILD_VERSION) but mono does not build binaries for each xcode release
# Xcode 12.4 Build 12D4e
XCODE_IOS_ARCHIVE_VERSION=xcode-12D4e
# Xcode 12.4 Build 12D4e
XCODE_MACOS_ARCHIVE_VERSION=xcode-12D4e
MONO_IOS_FILENAME:=ios-release-Darwin-$(MONO_HASH).7z
MONO_IOS_URL:=https://xamjenkinsartifact.azureedge.net/mono-sdks/$(XCODE_IOS_ARCHIVE_VERSION)/$(MONO_IOS_FILENAME)
MONO_MAC_FILENAME:=mac-release-Darwin-$(MONO_HASH).7z
MONO_MAC_URL:=https://xamjenkinsartifact.azureedge.net/mono-sdks/$(XCODE_MACOS_ARCHIVE_VERSION)/$(MONO_MAC_FILENAME)
MONO_MACCATALYST_FILENAME:=maccat-release-Darwin-$(MONO_HASH).7z
MONO_MACCATALYST_URL:=https://xamjenkinsartifact.azureedge.net/mono-sdks/$(XCODE_MACOS_ARCHIVE_VERSION)/$(MONO_MACCATALYST_FILENAME)

# Setup various variables depending on whether mono is downloaded or built from source
ifeq ($(MONO_BUILD_FROM_SOURCE),)
MONO_IOS_SDK_DESTDIR:=$(abspath $(TOP)/builds/downloads/$(basename $(MONO_IOS_FILENAME)))
MONO_MAC_SDK_DESTDIR:=$(abspath $(TOP)/builds/downloads/$(basename $(MONO_MAC_FILENAME)))
MONO_MACCATALYST_SDK_DESTDIR:=$(abspath $(TOP)/builds/downloads/$(basename $(MONO_MACCATALYST_FILENAME)))
MONO_BUILD_MODE=download-mono
else
MONO_IOS_SDK_DESTDIR:=$(abspath $(MONO_PATH)/sdks/out)
MONO_MAC_SDK_DESTDIR:=$(abspath $(MONO_PATH)/sdks/out)
MONO_MACCATALYST_SDK_DESTDIR:=$(abspath $(MONO_PATH)/sdks/out)
MONO_BUILD_MODE=compile-mono
endif

# This variable includes all the platforms we support, even those that might be disabled in this build.
ALL_PLATFORMS=iOS tvOS watchOS macOS
ALL_DOTNET_PLATFORMS=iOS macOS tvOS MacCatalyst

-include $(TOP)/dotnet.config
$(TOP)/dotnet.config: $(TOP)/eng/Versions.props $(TOP)/Build.props
	$(Q) grep MicrosoftDotnetSdkInternalPackageVersion $(TOP)/eng/Versions.props | sed -e 's/<*\/*MicrosoftDotnetSdkInternalPackageVersion>//g' -e 's/[ \t]*/DOTNET_VERSION=/' >> $@.tmp
	$(Q) grep MicrosoftNETCoreAppRefPackageVersion $(TOP)/eng/Versions.props | sed -e 's/<*\/*MicrosoftNETCoreAppRefPackageVersion>//g' -e 's/[ \t]*/BUNDLED_NETCORE_PLATFORMS_PACKAGE_VERSION=/' >> $@.tmp
	$(Q) grep "<$$(grep EmscriptenWorkloadVersion $(TOP)/eng/Versions.props | sed -e 's_.*>$$[\(]\(.*\)[\)]<.*_\1_')>" $(TOP)/eng/Versions.props | sed -e 's/.*>\(.*\)<.*/EMSCRIPTEN_MANIFEST_PACKAGE_VERSION=\1/' >> $@.tmp
	$(Q) $(foreach platform,$(ALL_DOTNET_PLATFORMS),grep Microsoft$(platform)SdkPackageVersion $(TOP)/eng/Versions.props | sed -e 's/<*\/*Microsoft$(platform)SdkPackageVersion>//g' -e 's/[ \t]*/NET7_$(shell echo $(platform) | tr '[:lower:]' '[:upper:]')_NUGET_VERSION_NO_METADATA=/' >> $@.tmp &&) true
	$(Q) mv $@.tmp $@

$(TOP)/Build.props: Make.config
	$(Q) rm -f $@.tmp
	$(Q) printf "<Project>\n" >> $@.tmp
	$(Q) printf "\t<PropertyGroup>\n" >> $@.tmp
ifeq ($(XCODE_IS_STABLE),true)
	# do nothing
else ifeq ($(XCODE_IS_STABLE),false)
	$(Q) printf "\t\t<EnablePreviewFeatures>true</EnablePreviewFeatures>\n" >> $@.tmp
else
	$(error "The variable XCODE_IS_STABLE is not set!")
endif
	$(Q) printf "\t</PropertyGroup>\n" >> $@.tmp
	$(Q) printf "</Project>\n" >> $@.tmp
	$(Q) mv $@.tmp $@

DOTNET_DESTDIR ?= $(TOP)/_build
DOTNET_NUPKG_DIR ?= $(DOTNET_DESTDIR)/nupkgs
DOTNET_PKG_DIR ?= $(DOTNET_DESTDIR)/pkgs

# Configuration for .NET 6.
# We're using preview versions, and there will probably be many of them, so install locally (into builds/downloads) if there's no system version to
# avoid consuming a lot of disk space (since they're never automatically deleted). The system-dependencies.sh script will install locally as long
# as there's a TARBALL url.

# If you build dotnet/runtime locally, "*-dev" is the version the built artifacts will use (and which we must reference)
CUSTOM_DOTNET_VERSION=6.0.0-dev

ifdef CUSTOM_DOTNET
DOTNET_BCL_VERSION=$(CUSTOM_DOTNET_VERSION)
export CUSTOM_DOTNET_VERSION
else
DOTNET_BCL_VERSION=$(BUNDLED_NETCORE_PLATFORMS_PACKAGE_VERSION)
endif


DOTNET_VERSION_BAND=$(firstword $(subst -, ,$(DOTNET_VERSION)))
DOTNET_VERSION_PRERELEASE_COMPONENT=$(subst $(DOTNET_VERSION_BAND),,$(DOTNET_VERSION))
DOTNET_INSTALL_NAME=dotnet-sdk-$(DOTNET_VERSION)
DOTNET_DIR=$(abspath $(TOP)/builds/downloads/$(DOTNET_INSTALL_NAME))
# DOTNET_ROOT is no longer considered to find dotnet as seen here dotnet/roslyn@f454d69
# but it seems that some tools like csc still needs it so let's export it.
export DOTNET_ROOT=$(DOTNET_DIR)
# dotnet now is being looked up in the PATH
export PATH := $(DOTNET_DIR):$(PATH)
DOTNET=$(DOTNET_DIR)/dotnet
DOTNET_BCL_DIR:=$(abspath $(TOP)/packages/microsoft.netcore.app.ref/$(DOTNET_BCL_VERSION)/ref/$(DOTNET_TFM))
ifneq ($(DOTNET_BCL_DIR),$(shell ls -1d $(DOTNET_BCL_DIR) 2>/dev/null))
DOTNET_BCL_DIR:=$(abspath $(TOP)/packages/microsoft.netcore.app.ref/$(DOTNET_BCL_VERSION)/ref/net7.0)
endif

# The sdk version band has the last two digits set to 0: https://github.com/dotnet/sdk/blob/22c4860dcb2cf6b123dd641cc4a87a50380759d5/src/Resolvers/Microsoft.NET.Sdk.WorkloadManifestReader/SdkDirectoryWorkloadManifestProvider.cs#L52-L53
DOTNET_MANIFEST_VERSION_BAND=$(shell echo $(DOTNET_VERSION_BAND) | sed 's/..$$/00/')
ifeq ($(DOTNET_VERSION_PRERELEASE_COMPONENT),)
DOTNET_MANIFEST_VERSION_BAND_WITH_PRERELEASE_COMPONENT=$(DOTNET_MANIFEST_VERSION_BAND)
else ifeq ($(word 1,$(subst ., ,$(DOTNET_VERSION_PRERELEASE_COMPONENT))),-rtm)
DOTNET_MANIFEST_VERSION_BAND_WITH_PRERELEASE_COMPONENT=$(DOTNET_MANIFEST_VERSION_BAND)
else ifeq ($(word 1,$(subst ., ,$(DOTNET_VERSION_PRERELEASE_COMPONENT))),-servicing)
DOTNET_MANIFEST_VERSION_BAND_WITH_PRERELEASE_COMPONENT=$(DOTNET_MANIFEST_VERSION_BAND)
else
DOTNET_MANIFEST_VERSION_BAND_WITH_PRERELEASE_COMPONENT=$(DOTNET_MANIFEST_VERSION_BAND)$(word 1,$(subst ., ,$(DOTNET_VERSION_PRERELEASE_COMPONENT))).$(word 2,$(subst ., ,$(DOTNET_VERSION_PRERELEASE_COMPONENT)))
endif

# These are the manifest version band used for Mono and Emscripten.
# It will typically be $(DOTNET_MANIFEST_VERSION_BAND_WITH_PRERELEASE_COMPONENT), unless the corresponding teams decided to hardcode something else.
MONO_TOOLCHAIN_MANIFEST_VERSION_BAND=$(DOTNET_MANIFEST_VERSION_BAND_WITH_PRERELEASE_COMPONENT)
EMSCRIPTEN_MANIFEST_VERSION_BAND=$(DOTNET_MANIFEST_VERSION_BAND_WITH_PRERELEASE_COMPONENT)

# This is the manifest version band we use for our .Manifest-$(VERSION_BAND) packages.
# It should typically be $(DOTNET_MANIFEST_VERSION_BAND_WITH_PRERELEASE_COMPONENT), unless we decide to hardcode it to something else
MACIOS_MANIFEST_VERSION_BAND=$(DOTNET_MANIFEST_VERSION_BAND_WITH_PRERELEASE_COMPONENT)

# Set this to 1 if the Microsoft.NETCore.App.Ref dependency in eng/Version.Details.xml does *not* specify a CoherentParentDependency on Microsoft.Dotnet.Sdk.Internal.
TRACKING_DOTNET_RUNTIME_SEPARATELY=

# Set this to 1 if the Microsoft.NETCore.App.Ref dependency in eng/Version.Details.xml does *not* specify a CoherentParentDependency on Microsoft.Dotnet.Sdk.Internal.
TRACKING_DOTNET_RUNTIME_SEPARATELY=

# The location of csc changes depending on whether we're using a preview or a stable/service release :/
DOTNET_CSC_PATH_PREVIEW=$(DOTNET_DIR)/sdk/$(DOTNET_VERSION)/Roslyn/bincore/csc.dll
DOTNET_CSC_PATH_STABLE=$(DOTNET_DIR)/sdk/$(DOTNET_VERSION_BAND)/Roslyn/bincore/csc.dll

# Attempt to detect where csc is based. This may fail in the future: feel free to fix/hardcode whatever's necessary to find csc.dll.
ifneq ("$(wildcard $(DOTNET_CSC_PATH_STABLE))","")
DOTNET_CSC=$(DOTNET) exec $(DOTNET_CSC_PATH_STABLE)
else
DOTNET_CSC=$(DOTNET) exec $(DOTNET_CSC_PATH_PREVIEW)
endif

# How are our assemblies named?
DOTNET_IOS_ASSEMBLY_NAME=Microsoft.iOS
DOTNET_TVOS_ASSEMBLY_NAME=Microsoft.tvOS
DOTNET_MACCATALYST_ASSEMBLY_NAME=Microsoft.MacCatalyst
DOTNET_MACOS_ASSEMBLY_NAME=Microsoft.macOS

DOTNET_PLATFORMS=
ifdef INCLUDE_IOS
ifdef ENABLE_DOTNET
DOTNET_PLATFORMS+=iOS
DOTNET_IOS_BITNESSES+=64
DOTNET_NATIVEAOT_PLATFORMS+=iOS

# 32-bit architectures
ifdef IOS_SUPPORTS_32BIT_ARCHITECTURES
DOTNET_IOS_BITNESSES+=32
ifdef INCLUDE_DEVICE
DOTNET_IOS_RUNTIME_IDENTIFIERS_32=ios-arm
endif # INCLUDE_DEVICE
DOTNET_IOS_RUNTIME_IDENTIFIERS_32+=iossimulator-x86
endif # IOS_SUPPORTS_32BIT_ARCHITECTURES

# 64-bit architectures
ifdef INCLUDE_DEVICE
DOTNET_IOS_RUNTIME_IDENTIFIERS_64=ios-arm64
endif # INCLUDE_DEVICE
DOTNET_IOS_RUNTIME_IDENTIFIERS_64+=iossimulator-x64 iossimulator-arm64

# All of them
DOTNET_IOS_RUNTIME_IDENTIFIERS=$(DOTNET_IOS_RUNTIME_IDENTIFIERS_32) $(DOTNET_IOS_RUNTIME_IDENTIFIERS_64)
endif # ENABLE_DOTNET
endif # INCLUDE_IOS

ifdef INCLUDE_TVOS
ifdef ENABLE_DOTNET
DOTNET_PLATFORMS+=tvOS
DOTNET_TVOS_BITNESSES+=64
DOTNET_NATIVEAOT_PLATFORMS+=tvOS
ifdef INCLUDE_DEVICE
DOTNET_TVOS_RUNTIME_IDENTIFIERS=tvos-arm64 tvossimulator-x64 tvossimulator-arm64
else
DOTNET_TVOS_RUNTIME_IDENTIFIERS=tvossimulator-x64 tvossimulator-arm64
endif
DOTNET_TVOS_RUNTIME_IDENTIFIERS_64+=$(DOTNET_TVOS_RUNTIME_IDENTIFIERS)
endif # ENABLE_DOTNET
endif

ifdef INCLUDE_DOTNET_WATCHOS
DOTNET_PLATFORMS+=watchOS
ifdef INCLUDE_DEVICE
DOTNET_WATCHOS_RUNTIME_IDENTIFIERS=watchos-arm watchos-x86
DOTNET_WATCHOS_RUNTIME_IDENTIFIERS_32=watchos-arm watchos-x86
else
DOTNET_WATCHOS_RUNTIME_IDENTIFIERS=watchos-x86 watchos-x64
DOTNET_WATCHOS_RUNTIME_IDENTIFIERS_32=watchos-x86
DOTNET_WATCHOS_RUNTIME_IDENTIFIERS_64=watchos-x64
endif
endif

ifdef INCLUDE_MACCATALYST
ifdef ENABLE_DOTNET
DOTNET_PLATFORMS+=MacCatalyst
DOTNET_MACCATALYST_BITNESSES+=64
DOTNET_NATIVEAOT_PLATFORMS+=MacCatalyst
DOTNET_MACCATALYST_RUNTIME_IDENTIFIERS=maccatalyst-x64 maccatalyst-arm64
DOTNET_MACCATALYST_RUNTIME_IDENTIFIERS_64+=$(DOTNET_MACCATALYST_RUNTIME_IDENTIFIERS)
endif # ENABLE_DOTNET
endif

ifdef INCLUDE_MAC
ifdef ENABLE_DOTNET
DOTNET_PLATFORMS+=macOS
DOTNET_CORECLR_PLATFORMS+=macOS
DOTNET_MACOS_BITNESSES+=64
DOTNET_NATIVEAOT_PLATFORMS+=macOS
DOTNET_MACOS_RUNTIME_IDENTIFIERS=osx-x64 osx-arm64
DOTNET_MACOS_RUNTIME_IDENTIFIERS_64=$(DOTNET_MACOS_RUNTIME_IDENTIFIERS)
endif # ENABLE_DOTNET
endif

ifdef INCLUDE_IOS
DOTNET_WINDOWS_PLATFORMS = iOS
endif

# Create variables prefixed with the correctly cased platform name from the upper-cased platform name. This simplifies code in a few areas (whenever we foreach over DOTNET_PLATFORMS).
$(foreach platform,$(DOTNET_PLATFORMS),$(eval DOTNET_$(platform)_RUNTIME_IDENTIFIERS:=$(DOTNET_$(shell echo $(platform) | tr a-z A-Z)_RUNTIME_IDENTIFIERS)))

# Create a variable with all the runtime identifiers
DOTNET_RUNTIME_IDENTIFIERS=$(foreach platform,$(DOTNET_PLATFORMS),$(DOTNET_$(platform)_RUNTIME_IDENTIFIERS))

# Create a variable with all the CoreCLR runtime identifiers
DOTNET_CORECLR_RUNTIME_IDENTIFIERS=$(foreach platform,$(DOTNET_CORECLR_PLATFORMS),$(DOTNET_$(platform)_RUNTIME_IDENTIFIERS))

# Create a variable with the platform in uppercase
DOTNET_PLATFORMS_UPPERCASE:=$(shell echo $(DOTNET_PLATFORMS) | tr a-z A-Z)

# All desktop platforms we're building for
DOTNET_DESKTOP_PLATFORMS:=$(filter macOS MacCatalyst,$(DOTNET_PLATFORMS))

# a few lookup tables, because the data we have is not always in the format we need it
DOTNET_iossimulator-x64_ARCHITECTURES=x86_64
DOTNET_iossimulator-arm64_ARCHITECTURES=arm64
DOTNET_iossimulator-x86_ARCHITECTURES=x86
DOTNET_ios-arm_ARCHITECTURES=armv7 armv7s
DOTNET_ios-arm64_ARCHITECTURES=arm64
DOTNET_tvossimulator-x64_ARCHITECTURES=x86_64
DOTNET_tvossimulator-arm64_ARCHITECTURES=arm64
DOTNET_tvos-arm64_ARCHITECTURES=arm64
DOTNET_osx-x64_ARCHITECTURES=x86_64
DOTNET_osx-arm64_ARCHITECTURES=arm64
DOTNET_maccatalyst-x64_ARCHITECTURES=x86_64
DOTNET_maccatalyst-arm64_ARCHITECTURES=arm64

DOTNET_iossimulator-x64_SDK_PLATFORM=iphonesimulator
DOTNET_iossimulator-arm64_SDK_PLATFORM=iphonesimulator
DOTNET_iossimulator-x86_SDK_PLATFORM=iphonesimulator
DOTNET_ios-arm_SDK_PLATFORM=iphoneos
DOTNET_ios-arm64_SDK_PLATFORM=iphoneos
DOTNET_tvossimulator-x64_SDK_PLATFORM=tvsimulator
DOTNET_tvossimulator-arm64_SDK_PLATFORM=tvsimulator
DOTNET_tvos-arm64_SDK_PLATFORM=tvos
DOTNET_osx-x64_SDK_PLATFORM=mac
DOTNET_osx-arm64_SDK_PLATFORM=mac
DOTNET_maccatalyst-x64_SDK_PLATFORM=maccatalyst
DOTNET_maccatalyst-arm64_SDK_PLATFORM=maccatalyst

DOTNET_iOS_SDK_PLATFORMS=iphonesimulator iphoneos
DOTNET_tvOS_SDK_PLATFORMS=tvsimulator tvos
DOTNET_macOS_SDK_PLATFORMS=mac
DOTNET_MacCatalyst_SDK_PLATFORMS=maccatalyst

# A local feed to place test nugets.
NUGET_TEST_FEED=$(abspath $(TOP)/tests/.nuget/packages)

.SUFFIXES:
MAKEFLAGS += --no-builtin-rules
